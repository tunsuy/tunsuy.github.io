<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Python中的异步编程详解]]></title>
      <url>%2F2017%2F03%2F05%2FPython%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[一、 协程和线程多线程的Python程序总是让你看起来像是同时在运行多个函数。但是多线程有三大问题： 它们需要特殊的工具来协调各个线程之间的安全。这让编写代码比单线程程序更加的苦难。并且这让代码变得更加的难以维护和扩展。 线程需要更多的内存，每个执行中的线程大概需要8M。这对于现在大部分计算机来说可能不算什么。但是如果你想让你的程序同时运行成千上万的功能，这可能就会导致有些线程不工作了。 开启一个线程的代价是很高的。如果你频繁的创建和销毁一个线程，那么这开销将会是很大的，将拖慢整个系统。 Python用协程将解决这些问题。协程让你的Python程序看起来有很多同时工作的函数功能。它们被实现为作为生成器的扩展功能。开启一个生成器协程的代价就只相当于一个函数调用。一旦开启协程，它们的内存消耗少于1KB。 关于Python的协程发展，这篇文章讲的比较好 python的协程 下面先来看看Python中的生成器 二、 生成器简单来说，生成器就是一个生产值的方法。一个方法通常返回一个值之后，内存调用栈中就会将该方法的调用信息给销毁了。当我们再次调用该方法时，又会从入口开始从头执行，它是一次性执行的。但是一个生成器能够 yield 一个值，并且暂停该方法的执行吗，同时将线程控制器交给调用者。当我们想要得到其他值的时候，又可以再次恢复这个方法的执行。示例：12345678def simple_gen(): yield "Hello" yield "World"gen = simple_gen()print(next(gen))print(next(gen)) 注：一个生成器方法被调用时不会直接返回任何的值，而是当返回一个生成器对象（类似于迭代器）。我们可以对这个生成器调用 next() 方法来获取每一个值，或者运行 for 循环。 生成器有什么用呢？ 假如你的老板要求你写一个方法来生成100以内的序列（一个 range() 的超级简化版本）。你可能这样实现它：你定义一个空列表，然后将数字添加进入，最后返回该列表。后来这个需求变更了，需要生成千万的序列。这时如果你在一个列表中存储千万的数据，这将导致内存溢出。这时，生成器可以解决这个问题：你可以生成这些数据，但是不用存储在列表中，下面是示例：1234567891011121314def generate_nums(): num = 0 while True: yield num num = num + 1nums = generate_nums()for x in nums: print(x) if x &gt; 9: break 三、 协程在上一节中，我们已经看见了，使用生成器我们可以从方法上下文中拿到数据。那如果我们也想要传递一些数据给该方法上下文中的变量呢？这就是协程发挥的作用了。yield 关键字能够用来获取数据，也能作为一个表达式。我们能够对生成器对象使用 send() 方法来传递数据给方法。这就是所谓的 “基于生成器的协程”。示例：12345678def coro(): hello = yield "Hello" yield helloc = coro()print(next(c))print(c.send("World")) 这段代码是怎样工作的呢？首先我们执行 next(c), 第一次拿到 coro() 中的数据 Hello (此时 coro() 方法暂停，等待下一次恢复)。然后我们通过 send() 方法向方法 coro() 传递一个值 World，此时 coro() 方法恢复执行，并且将我们发送的数据赋值给 hello 变量。并开始往下执行直到遇到下一个 yield ，此时方法返回 World 。 Python的生成器是协程coroutine的一种形式，但它的局限性在于只能向它的直接调用者yield值。这意味着那些包含yield的代码不能想其他代码那样被分离出来放到一个单独的函数中。这也正是 yield from 要解决的。 四、 yield from yield from 允许一个generator生成器将其部分操作委派给另一个生成器。其产生的主要动力在于使生成器能够很容易分为多个拥有send和throw方法的子生成器，像一个大函数可以分为多个子函数一样简单。示例： 1234567891011121314151617181920212223242526&gt;&gt;&gt; def accumulate(): # 子生成器，将传进的非None值累加，传进的值若为None，则返回累加结果... tally = 0... while 1:... next = yield... if next is None:... return tally... tally += next...&gt;&gt;&gt; def gather_tallies(tallies): # 外部生成器，将累加操作任务委托给子生成器... while 1:... tally = yield from accumulate()... tallies.append(tally)...&gt;&gt;&gt; tallies = []&gt;&gt;&gt; acc = gather_tallies(tallies)&gt;&gt;&gt; next(acc) # 使累加生成器准备好接收传入值&gt;&gt;&gt; for i in range(4):... acc.send(i)...&gt;&gt;&gt; acc.send(None) # 结束第一次累加&gt;&gt;&gt; for i in range(5):... acc.send(i)...&gt;&gt;&gt; acc.send(None) # 结束第二次累加&gt;&gt;&gt; tallies # 输出最终结果[6, 10] 基于生成器的协程在Python2.5以上就有了，但是在Python3.5，又有了更加灵活强大的协程支持 async/await 以及本地协程。 五、 异步I/O从Python3.4起，有了一个叫做 asyncio 的新模块，提供了很多好的API来处理异步程序。我们可以使用协程和asyncio模块更加容易的处理异常程序。示例：123456789101112131415161718192021import asyncioimport datetimeimport random@asyncio.coroutinedef display_date(num, loop): end_time = loop.time() + 50.0 while True: print("Loop: &#123;&#125; Time: &#123;&#125;".format(num, datetime.datetime.now())) if (loop.time() + 1.0) &gt;= end_time: break yield from asyncio.sleep(random.randint(0, 5))loop = asyncio.get_event_loop()asyncio.ensure_future(display_date(1, loop))asyncio.ensure_future(display_date(2, loop))loop.run_forever() 这段代码中，我们创建了一个协程 display_date(num, loop) 。它使用一个 yield from 来等待子协程 asyncio.sleep() 的返回结果。asyncio.sleep() 是一个协程，在给定的时间之后完成。因此我们传递随机的时间给它。然后我们使用 asyncio.ensure_future() 在默认时间循环中调度 display_date() 协程的执行。 通过输出，我们可以看到两个协程在并发的执行。当我们使用 yield from 时，这事件循环知道它将耗时一会，所以它会自动中断这个协程的执行，转而去执行另外一个。因此看起来是并发的执行（但不是并行，因为事件循环是一个单线程）。 正如你知道的，yield from 是一个语法糖：for x in asyncio.sleep(random.randint(0, 5)): yield x。 六、 原生协程在Python3.5起，提供了 async/await 来支持原生协程。上一节的代码可以这样重写：1234567891011121314151617181920import asyncioimport datetimeimport randomasync def display_date(num, loop, ): end_time = loop.time() + 50.0 while True: print("Loop: &#123;&#125; Time: &#123;&#125;".format(num, datetime.datetime.now())) if (loop.time() + 1.0) &gt;= end_time: break await asyncio.sleep(random.randint(0, 5))loop = asyncio.get_event_loop()asyncio.ensure_future(display_date(1, loop))asyncio.ensure_future(display_date(2, loop))loop.run_forever() 七、 两种模式对比原生协程和基于生成器的协程在功能上没有什么差异，除了使用的关键字不同而已。两者之间不能混用，比如在原生中使用 yield/yield from ，在基于生成器的协程中使用 await 。 尽管有使用上的不同，但是我们也可以对他们进行互操作。我们只需要增加 @types.coroutine 装饰器到旧的基于生成器协程上。也就是说，我们能够在原生协程中使用 await 来等待一个基于生成器的协程，在基于生成器的协程中使用 yield from 来等待一个原生协程。示例：1234567891011121314151617181920212223242526import asyncioimport datetimeimport randomimport types@types.coroutinedef my_sleep_func(): yield from asyncio.sleep(random.randint(0, 5))async def display_date(num, loop, ): end_time = loop.time() + 50.0 while True: print("Loop: &#123;&#125; Time: &#123;&#125;".format(num, datetime.datetime.now())) if (loop.time() + 1.0) &gt;= end_time: break await my_sleep_func()loop = asyncio.get_event_loop()asyncio.ensure_future(display_date(1, loop))asyncio.ensure_future(display_date(2, loop))loop.run_forever()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[高效Python编程之方法参数]]></title>
      <url>%2F2017%2F02%2F18%2F%E9%AB%98%E6%95%88Python%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%2F</url>
      <content type="text"><![CDATA[一、 可变数量参数1、 概述可变数量参数是指参数前带 * 的。如 *args.比如，你想要通过一些参数信息来打印日志。使用固定参数如下：12345678910111213def log(message, values): if not values: print(message) else: values_str = ', '.join(str(x) for x in values) print('%s: %s' % (message, values_str))log('My numbers are', [1, 2])log('Hi there', [])&gt;&gt;&gt;My numbers are: 1, 2Hi there 可以看出，当你没有values值传递的时候，你也不得不传递一个 [] 。 最好的做法就是没有值，第二个参数就留空。那么你能够在最后一个参数前加 * 来达到这样的效果。那么最后一个参数，你传递多少个值都是合法的。如下所示：12345678910111213def log(message, *values): # The only difference if not values: print(message) else: values_str = ', '.join(str(x) for x in values) print('%s: %s' % (message, values_str))log('My numbers are', 1, 2)log('Hi there') # Much better&gt;&gt;&gt;My numbers are: 1, 2Hi there 如果你已经有了一个列表变量，想要传递给像log这样的可选参数方法。你能够直接在列表变量前加 * 传递给方法。这表示让Python将列表中的元素项依次传递给方法。示例：12345favorites = [7, 33, 99]log('Favorite colors', *favorites)&gt;&gt;&gt;Favorite colors: 7, 33, 99 2、 问题注意接受可变位置的可变数量的参数有两个问题： 第一个问题就是可变参数在被传递到方法中时总是被转换为一个元组。这就意味着如果一个方法的参数是生成器前加 * 。那么该生成器参数将全部迭代完所有的元素，然后返回包含来自该生成器的所有元素组成的元组，这就有可能在数据量比较大的时候占用很大的内存，导致程序crash。123456789101112def my_generator(): for i in range(10): yield idef my_func(*args): print(args)it = my_generator()my_func(*it)&gt;&gt;&gt;(0, 1, 2, 3, 4, 5, 6, 7, 8, 9) 第二个问题就是参数是位置对应的，传递的参数需要根据参数位置来传递，如果中间某个参数没有，那么可变参数中的元素将被填充到那个没有传参的参数中，具体示例如下：12345678910111213def log(sequence, message, *values): if not values: print('%s: %s' % (sequence, message)) else: values_str = ', '.join(str(x) for x in values) print('%s: %s: %s' % (sequence, message, values_str))log(1, 'Favorites', 7, 33) # New usage is OKlog('Favorite numbers', 7, 33) # Old usage breaks&gt;&gt;&gt;1: Favorites: 7, 33Favorite numbers: 7: 33 二、 关键字参数1、 概述跟其他程序语言一样，在Python中调用方法允许使用位置来传递参数。1234def remainder(number, divisor): return number % divisorassert remainder(20, 7) == 6 在Python中所有的位置参数也都可以使用关键字来传递，方法定义中的关键字也就是方法调用中的赋值变量。关键字参数能够以任意的位置来传递，也能够同位置参数混合使用。下面的调用都是等效的：1234remainder(20, 7)remainder(20, divisor=7)remainder(number=20, divisor=7)remainder(divisor=7, number=20) 2、 问题注意位置参数必现在关键字参数之前被指定，看下面就是一个违法的调用：1234remainder(number=20, 7)&gt;&gt;&gt;SyntaxError: non-keyword arg after keyword arg 每一个参数只能被指定一次：1234remainder(20, number=7)&gt;&gt;&gt;TypeError: remainder() got multiple values for argument 'number' 3、 优点使用关键字参数让程序可读性更好，通过参数名即可知道传递的参数的作用。 关键字参数可以指定默认的值，这对于某些逻辑是很有作用的。在调用的时候则可以不用传递参数，那么该方法将使用默认的值。示例：12def flow_rate(weight_diff, time_diff, period=1): return (weight_diff / time_diff) * period 调用：12flow_per_second = flow_rate(weight_diff, time_diff)flow_per_hour = flow_rate(weight_diff, time_diff, period=3600) 有利于程序的扩展性。可以对增加的关键字使用默认值，达到向后兼容的效果，不需要改动已有的代码，示例：123def flow_rate(weight_diff, time_diff, period=1, units_per_kg=1): return ((weight_diff * units_per_kg) / time_diff) * period 新增的调用逻辑：12pounds_per_hour = flow_rate(weight_diff, time_diff, period=3600, units_per_kg=2.2) 三、 动态默认参数有时候你可能需要一个动态的默认参数值。先来看一个列子：12345678910def log(message, when=datetime.now()): print('%s: %s' % (when, message))log('Hi there!')sleep(0.1)log('Hi again!')&gt;&gt;&gt;2014-11-15 21:10:10.371432: Hi there!2014-11-15 21:10:10.371432: Hi again! 我们发现这个时间是一样的，这是因为 datetime.now() 只执行了一次：当这个函数被定义的时候。这是因为当程序启动的时候，加载模块，这个模块包含的代码也被加载了，那么这个默认参数值就被确认了。 一般的做法是给这个参数赋 None 值，然后在代码文档注释中说明。具体动态默认值在程序中指定。示例：12345678910def log(message, when=None): """Log a message with a timestamp. Args: message: Message to print. when: datetime of when the message occurred. Defaults to the present time. """ when = datetime.now() if when is None else when print('%s: %s' % (when, message)) 这时输出就是动态的参数值了：1234567log('Hi there!')sleep(0.1)log('Hi again!')&gt;&gt;&gt;2014-11-15 21:10:10.472303: Hi there!2014-11-15 21:10:10.573395: Hi again! 使用None作为参数默认值时很重要的，特别是当你的参数是可变的时候。比如，你想要加载一个data，并使用json编码。如果编码失败，你想要返回一个空的字典。你可能这样做：12345def decode(data, default=&#123;&#125;): try: return json.loads(data) except ValueError: return default 这个效果之前一个列子一样，所有的调用使用的都是同样的默认值，这会导致无法预期的效果：12345678910foo = decode('bad data')foo['stuff'] = 5bar = decode('also bad')bar['meep'] = 1print('Foo:', foo)print('Bar:', bar)&gt;&gt;&gt;Foo: &#123;'stuff': 5, 'meep': 1&#125;Bar: &#123;'stuff': 5, 'meep': 1&#125; 可以发现，两个对象的值都是一样的，改变一个影响了另一个。这是因为两个都是同一个默认值，指向的是同一个对象。1assert foo is bar 使用 None 作为默认值可以解决这个问题1234567891011121314def decode(data, default=None): """Load JSON data from a string. Args: data: JSON data to decode. default: Value to return if decoding fails. Defaults to an empty dictionary. """ if default is None: default = &#123;&#125; try: return json.loads(data) except ValueError: return default 现在调用可以发现是正确的了：12345678910foo = decode('bad data')foo['stuff'] = 5bar = decode('also bad')bar['meep'] = 1print('Foo:', foo)print('Bar:', bar)&gt;&gt;&gt;Foo: &#123;'stuff': 5&#125;Bar: &#123;'meep': 1&#125; 四、 强制使用关键字参数比如，你在处理两个数相除时，有时候可能想要忽略 ZeroDivisionError 异常，返回无穷大。有时候想要忽略 OverflowError 异常，返回0.1234567891011121314def safe_division(number, divisor, ignore_overflow, ignore_zero_division): try: return number / divisor except OverflowError: if ignore_overflow: return 0 else: raise except ZeroDivisionError: if ignore_zero_division: return float('inf') else: raise 调用：12345result = safe_division(1, 10**500, True, False)print(result)&gt;&gt;&gt;0.0 或者：12345result = safe_division(1, 0, False, True)print(result)&gt;&gt;&gt;inf 但是你会发现只看调用，是非常不直观的，不知道每个参数是什么意思，这时可以用关键字参数来指示：1234def safe_division_b(number, divisor, ignore_overflow=False, ignore_zero_division=False): # ... 调用：12safe_division_b(1, 10**500, ignore_overflow=True)safe_division_b(1, 0, ignore_zero_division=True) 但是还有一个问题就是，这个关键字参数是可选，你任然可以使用位置参数来调用：1safe_division_b(1, 10**500, True, False) 那么可不可以强制调用者使用关键字呢？在Python3中可以这样做：在参数中加一个 * 参数，表示之前的参数是位置参数，之后的参数是关键字参数，必须强制表明。1234def safe_division_c(number, divisor, *, ignore_overflow=False, ignore_zero_division=False): # ... 现在使用位置参数来调用将报错：1234safe_division_c(1, 10**500, True, False)&gt;&gt;&gt;TypeError: safe_division_c() takes 2 positional arguments but 4 were given 正确调用：123456safe_division_c(1, 0, ignore_zero_division=True) # OKtry: safe_division_c(1, 0)except ZeroDivisionError: pass # Expected 五、 可变数量关键字参数将数量不定的可变数量关键字参数传递给方法时，可以使用 ** 参数。123456789def print_args(*args, **kwargs): print 'Positional:', args print 'Keyword: ', kwargsprint_args(1, 2, foo='bar', stuff='meep')&gt;&gt;&gt;Positional: (1, 2)Keyword: &#123;'foo': 'bar', 'stuff': 'meep'&#125; 调用的时候，会将传递的所有的关键字参数传递给 kwargs 参数，Python会将其转化成一个字典。 六、 参数顺序几种方法参数的定义顺序为：位置参数，关键字参数，非关键字可变长参数(*args)，可变数量关键字参数(**kwargs)。 根据传递的参数顺序来依次匹配，先逐级匹配，如果还有剩余的参数再匹配下一级参数。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[深入了解Python中的装饰器]]></title>
      <url>%2F2017%2F02%2F07%2F%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Python%E4%B8%AD%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8%2F</url>
      <content type="text"><![CDATA[一、 概述Python的装饰器是AOP编程的一种实现，其他很多语言也都支持装饰器模式。注：AOP是指面向切面编程，详见 AOP概念 一个装饰器允许你增加、修改或者完全修改一个方法或者函数的逻辑。使用装饰器，将与业务无关的逻辑移到装饰器中，这将会让你的代码更加的干净紧凑。 二、 装饰器举例最经典的例子当然是Python内建的装饰器：@staticmethod 和 @classmethod 。这些装饰器将一个类中的方法转换为静态方法(该方法的第一个参数不是 self)，和类方法(该方法的第一个参数是 cls)。 如下所示：123456789101112class A(object): @classmethod def foo(cls): print cls.__name__ @staticmethod def bar(): print 'I have no use for the instance or class'A.foo()A.bar() 输出：12AI have no use for the instance or class 三、 装饰器定义装饰器就是一个接受一个可调用对象(被装饰的目标)的可调用对象，返回一个和源目标(被装饰对象)接受相同参数的可调用对象(装饰器)。 下面来解释下这段文字： 首先，什么是可调用对象呢？一个可调用对象在Python中就是包含一个叫 call() 方法的对象。具体来说就是可以是代码块、方法或者类。你也可以给你自己的类实现这个 call() 方法，这样你的类实例就变成了一个可调用对象，为了检测一个对象是否是可调用的，你可以在命令行中使用内建的 callable() 方法测试下：12345callable(len)Truecallable('123')False 注意：callable() 方法在Python3.0被移除了，但是在Python3.2又重新加入了。 四、 函数装饰器一个函数装饰器是用来装饰一个函数或者方法的。假设我们想要在每个执行之前都先输出一个字符串”Yeah, it works!”。下面以非装饰器的方式来实现它。原始方法：1234def foo(): print 'foo() here'foo() 输出：1foo() here 下面以一种很丑陋的方式来实现我们的需求12345678original_foo = foodef decorated_foo(): print 'Yeah, it works!' original_foo()foo = decorated_foofoo() 输出：12Yeah, it works!foo() here 这种方式有几个问题： 它会增加很多工作 用中间名字污染了名字空间，如：original_foo() 和 decorated_foo() 你不得不对每一个你想要增加这个需求的方法增加同样的逻辑 然而用迭代器同样能够实现这样的需求，并且是可以重用的。如下所示：12345def yeah_it_works(f): def decorated(*args, **kwargs): print 'Yeah, it works' return f(*args, **kwargs) return decorated 注：yeah_it_works() 是一个接受一个可调用对象f的函数。返回一个接受任何类型和数量的参数的可调用对象(嵌套函数 decorated)现在我们可以在任何函数中重用它123456789101112131415@yeah_it_worksdef f1() print 'f1() here'@yeah_it_worksdef f2() print 'f3() here'@yeah_it_worksdef f3() print 'f3() here'f1()f2()f3() 输出：123456Yeah, it worksf1() hereYeah, it worksf2() hereYeah, it worksf3() here 五、 类装饰器类装饰器是装饰整个类。它们在类定义时被替换。你能够对一个装饰器类增加或者减少方法，甚至将迭代器应用到所有的类的方法中。 假设我们要跟踪一个类抛出的所有异常，让我们假设已经有了一个函数装饰器叫 track_exceptions_decorator ，如果没有类装饰器，那么我们需要对每个方法应用这个函数装饰器或者采用 metaclasses。示例：1234567891011121314class A(object): @track_exceptions_decorator def f1(): ... @track_exceptions_decorator def f2(): ... . . . @track_exceptions_decorator def f100(): ... 一个类装饰器可以达到相同的效果：12345678910111213141516def track_exception(cls): # Get all callable attributes of the class callable_attributes = &#123;k:v for k, v in cls.__dict__.items() if callable(v)&#125; # Decorate each callable attribute of to the input class for name, func in callable_attributes.items(): decorated = track_exceptions_decorator(func) setattr(cls, name, decorated) return cls@track_exceptionsclass A: def f1(self): print('1') def f2(self): print('2')]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[深入详解Java的NIO之Buffer]]></title>
      <url>%2F2016%2F12%2F18%2F%E6%B7%B1%E5%85%A5%E8%AF%A6%E8%A7%A3Java%E7%9A%84NIO%E4%B9%8BBuffer%2F</url>
      <content type="text"><![CDATA[一、 简介Buffer是一个写入通道或者从通道中读取的数据块。Buffer是Java I/O和Java NIO的主要差异之一。对于早期的Java I/O，数据是基于流的方式进行读写的，而现在NIO是基于buffer的方式来读写的。NIO中的通道跟流是一个意思。 二、 Buffer特性 Buffer是Java NIO的基本构成组件。 Buffer提供了一个固定大小的容器来读写数据。 每个buffer都是可读的，但是只有被选中的buffer才是可写的。 Buffer是通道的端点。 在一个只读buffer中，内容是不可变的，但是它的 mark, position, limit 是可变的。 默认的buffer是线程不安全的 Buffer的读写模式如图所示： 三、 Buffer的类型每个基本类型都有一个buffer类型想对应。所有的buffer类都实现了 Buffer 接口。大部分使用的类型是 ByteBuffer。下面是在Java NIO包中可用的buffer类型： ByteBuffer CharBuffer ShortBuffer IntBuffer LongBuffer FloatBuffer DoubleBuffer MappedByteBuffer如图所示： 这些类都不能直接实例化，因为他们都是抽象类，但是每个都包含了静态工厂方法来创建适当类的实例。 四、 Buffer的基本属性Buffer有四个基本的属性，下面简单介绍下 1、容量CapacityBuffer是一个固定大小的类型，这个最大固定大小就叫做capacity。一旦这个buffer是满了，那么就应该在写入它之前清空它。一旦capacity被设置，在它的生命周期内就不能再被改变了。 2、上界Limit对于写模式，limit 是等于buffer的 capacity的。对于读模式，limit是buffer的最后填充索引的下一个。当buffer被写入时，limit会自增。limit满足下面的条件： 0 &lt;= limit &lt;= capacity 3、位置PositionPosition是buffer中下一个要被读或者写的元素的索引。当buffer被创建时，position被初始化为0。当读写时，position是自增的。position总是处于0和limit之间。 4、标记MarkMark就像是buffer中为position设置的书签一样。调用 mark() 来设定 mark = position，调用 reset() 来设定 position = mark 。 五、 Buffer相关操作1、flip()该方法被用来为 get() 操作准备一个 buffer ，或者是用来准备一个新的写序列。flip() 方法设置 limit 等于buffer的当前 position，然后将 position = 0。 2、clear()该方法用来为 put() 操作准备一个 buffer，或者用来准备一个新的读序列。clear() 方法设置 limit = capacity 和 position = 0。 3、rewind()该方法用来再次读取数据。它设置 position = 0。 六、 Buffer的创建Buffer是通过 allocation 或者 wrapping 来创建的。allocation 创建一个buffer对象，并且分配指定容量的私有空间来容纳数据元素。wrapping 创建一个buffer对象，但是不分配任何的空间来保存数据元素，它使用你提供的数组空间来存储buffer的数据元素。 举例，创建一个能够容纳100个字符的 CharBuffer：1CharBuffer charBuffer = CharBuffer.allocate (100); 上面这种方式，隐式的从堆上分配了一个char数组来存储这100个字符。如果你想要使用你自己创建的数组来存储，则使用 wrap() 方法：12char [] myArray = new char [100];CharBuffer charbuffer = CharBuffer.wrap (myArray); 这意味着通过调用 put() 方法对buffer做的变更都会反映到这个数组中。同样的，对这个数组做的任何改变都将反映到buffer中。 你也能够通过指定偏移和长度值作为 position 和 limit 来构造buffer：12char [] myArray = new char [100];CharBuffer charbuffer = CharBuffer.wrap (myArray , 12, 42); 注： 这个方法不会创建一个buffer，而是指向改数组的一个子集 这个方法拥有这个数组整体的访问权，偏移和长度参数仅仅只是设置初始状态。 调用这个buffer的 clear() 方法将使它的 limit 范围变为这个数组的所有元素 调用 slice() 方法能够创建一个buffer指向这个数组的一部分 通过 allocate() 或者 wrap() 方法创建的buffer都不是直接在内存中开辟空间的，而是指向一个已有的数组。使用 hasArray() 方法告诉你这个buffer是否有一个相关联的数组，如果返回 true，则可以使用 array() 方法返回一个数组的引用给buffer。如果返回 false，就不要调用 array() 和 arrayOffset()，否则将抛出 UnsupportedOperationException 异常。 七、访问Buffer每个buffer类都提供了 get() 和 put() 方法来访问buffer，比如：12345678public abstract class ByteBuffer extends Buffer implements Comparable&#123; // This is a partial API listing public abstract byte get(); public abstract byte get (int index); public abstract ByteBuffer put (byte b); public abstract ByteBuffer put (int index, byte b);&#125; 访问API有绝对和相对之分，调用相对访问API时，position 会自动的向前进一个，调用绝对访问API时，指定索引位置的内容会被覆盖掉或者按指定索引返回内容。 八、 Buffer的比较 所有的buffer类都提供了一个自定义的 equals() 方法 和 compareTo() 方法，比如： 123if (buffer1.equals (buffer2)) &#123; doSomething();&#125; 两个buffer按照下面的规则进行比较： 包含的对象必须是同等类型的 两个buffer必须包含有相等数量的元素， 也就是说，buffer的容量不需要相同，buffer中剩余的数据索引不需要相同，但是buffer中剩余元素的数量（从 position 到 limit）必须相同 从 get() 返回的剩余数据元素的序列在每个缓冲区中必须相同。 buffer还支持使用compareTo()方法进行词典比较。该方法返回一个正数、负数或者0。比如：123if (buffer1.compareTo (buffer2) &gt; 0) &#123; doSomething();&#125; 参考文章 Working With Buffers]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[深入详解Java的NIO之Channel]]></title>
      <url>%2F2016%2F12%2F13%2F%E6%B7%B1%E5%85%A5%E8%AF%A6%E8%A7%A3Java%E7%9A%84NIO%E4%B9%8BChannel%2F</url>
      <content type="text"><![CDATA[一、 简介通道是java.nio在buffer之后的第二个主要创新。通道提供与I/O服务的直接连接。通道是一种在字节缓冲区和通道另一端的实体（通常是文件或套接字）之间高效传输数据的介质。通常通道与操作系统文件描述符具有一对一的关系。通道类提供了支持平台无关性所需的抽象，但仍然具有对现代操作系统的本机I/O建模的能力。通道是网关，通过它可以以最小的开销访问操作系统的本地I/O服务。 二、 Channel接口通道与缓冲区不同，通道 API 主要由接口指定。不同的操作系统上通道实现（Channel Implementation）会有根本性的差异，所以通道 API 仅仅描述了可以做什么。因此很自然地，通道实现经常使用操作系统的本地代码。通道接口允许您以一种受控且可移植的方式来访问底层的 I/O服务。 通道类簇图如下： Channel 作为NIO通道类的顶层类，是一个接口，如下：1234567package java.nio.channels;public interface Channel&#123; public boolean isOpen(); public void close() throws IOException;&#125; 从 Channel 接口引申出的其他接口都是面向字节的子接口，包括 Writable ByteChannel 和ReadableByteChannel。这也正好支持了我们之前所学的：通道只能在字节缓冲区上操作。 三、 打开通道作为我们都知道的，I/O 分为两大类：文件I/O 和 流I/O。因此，这也就对应两种通道类型：FileChannel类 和 SocketChannel类 FileChannel 对象只能通过在一个打开的RandomAccessFile，FileInputStream 或 FileOutputStream 对象上调用 getChannel() 方法获得。示例：12RandomAccessFile raf = new RandomAccessFile ("somefile", "r");FileChannel fc = raf.getChannel(); 相对于 FileChannel，SocketChannel 自身有工厂方法来创建新的socket通道，示例：12345678910//How to open SocketChannelSocketChannel sc = SocketChannel.open();sc.connect(new InetSocketAddress("somehost", someport));//How to open ServerSocketChannelServerSocketChannel ssc = ServerSocketChannel.open();ssc.socket().bind (new InetSocketAddress (somelocalport));//How to open DatagramChannelDatagramChannel dc = DatagramChannel.open(); 四、 使用通道通过实现以下接口的相关方法，可以实现读写操作：12345678910111213public interface ReadableByteChannel extends Channel&#123; public int read (ByteBuffer dst) throws IOException;&#125;public interface WritableByteChannel extends Channel&#123; public int write (ByteBuffer src) throws IOException;&#125;public interface ByteChannel extends ReadableByteChannel, WritableByteChannel&#123;&#125; 通道可以是单向或者双向的，一个通道类只实现 ReadableByteChannel 接口，那么它就是单向的只读通道；如果一个通道类只实现 WritableByteChannel 接口，那么它就是单向的只写通道。如果一个通道类两者都实现了，那么它就是双向的可读写通道。 文件通道和socket通道都实现了这三个接口，都是双向通道。 对于文件通道来说，有一点需要注意：通过 FileInputStream 对象的 getChannel() 方法获得的 FileChannel 对象是只读的，但是因为 FileChannel 实现了 ByteChannel ，所以从接口层面上是双向的。如果在 FileChannel 上调用 write() 方法将抛出 NonWritableChannelException 异常。因此，请记住，当通道连接到特定的I/O服务时，通道实例的功能将受其连接的服务的特性约束：连接到只读文件的通道实例无法写入，即使该通道实例所属的类可能具有write()方法。示例：123456FileInputStream input = new FileInputStream ("readOnlyFile.txt");FileChannel channel = input.getChannel();// This will compile but will throw an IOException// because the underlying file is read-onlychannel.write (buffer); ByteChannel 的 read() 和 write() 方法以ByteBuffer对象作为参数。返回传输的字节数，可以小于缓冲区中的字节数，甚至为零。如果执行了部分传输，则可以将缓冲区重新传递到通道，以在其中断的地方继续传输数据。如此重复，直到缓冲区的 hasRemaining() 方法返回false。 五、工作模式通道可以工作在阻塞或非阻塞模式。非阻塞模式下，所请求的操作可以立即完成，也可以返回表示什么都没有完成的结果。 只有面向流的信道，例如套接字和管道，可以被置于非阻塞模式。 FileChannel 总是阻塞的，因此不能被设置成非阻塞模式 六、 关闭通道想要关闭通道，需要使用 close() 方法。一个被关闭的通道不能再被使用。 可以对一个通道多次调用 close() 方法，对一个已关闭的通道调用 close() 方法时，什么都不做，直接返回。 可以使用 isOpen() 放来检查一个通道的打开状态。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[自编译mongo3.2测试]]></title>
      <url>%2F2016%2F12%2F09%2F%E8%87%AA%E7%BC%96%E8%AF%91mongo3-2%E6%B5%8B%E8%AF%95%2F</url>
      <content type="text"><![CDATA[一、 简介公司将mongodb删除机制进行了自定义，改动了相关源码，故需要配合测试mongodb的功能是否正常 二、 检查服务器1、 检查mongo启动情况12netstat -anpt | grep mong* | grep 0.0.0.0mongoa --port 27020（相应的端口）——进入mongo 2、 集群数据库情况cat /etc/hosts | grep db——3个数据库分片（sh0，sh1，sh2）——2个统计分片（statis-sh0，statis-sh1） 也可以这样查看： 进入mongos（169.100下） 进入config数据库中1db.shards.find() 三、 主备切换测试1、 shard0： 随便进入一个sh0节点服务器通过/etc/hosts可以查看到（169.100下） 查看sh0集群情况： rs.status()找到sh0主节点服务器，并进入, 执行rs.stepDown()——切换主备 检查主备切换是否成功rs.status()——集群情况 2、 依次对shard1、shard2集群进行主备切换也可以关注下主备切换的日志情况1find / -name mongo*.log（找到各mongo进程log） 四、 chunk迁移测试（以迁移customer.info表为例） 1、 查看迁移之前的chunk情况1234567891011121314151617181920212223242526272829303132use configdb.chunks.find(&#123;"_id":/customer.info-did_10000*/, "ns":"customer.info"&#125;).pretty()&#123; "_id" : "customer.info-did_10000custmid_100", "lastmod" : Timestamp(135, 0), "lastmodEpoch" : ObjectId("54ae3eaaf3a2f2e7d3726927"), "ns" : "customer.info", "min" : &#123; "did" : NumberLong(10000), "custmid" : NumberLong(100) &#125;, "max" : &#123; "did" : NumberLong(10000), "custmid" : NumberLong(1948) &#125;, "shard" : "shard0"&#125;&#123; "_id" : "customer.info-did_10000custmid_1948", "lastmod" : Timestamp(136, 0), "lastmodEpoch" : ObjectId("54ae3eaaf3a2f2e7d3726927"), "ns" : "customer.info", "min" : &#123; "did" : NumberLong(10000), "custmid" : NumberLong(1948) &#125;, "max" : &#123; "did" : NumberLong(10039), "custmid" : NumberLong(451) &#125;, "shard" : "shard2"&#125; 2、 执行迁移命令123 sh.moveChunk("customer.info", &#123;did:10000,custmid:100&#125;, "shard1")#或者 db.adminCommand(&#123;moveChunk:"customer.info", find:&#123;did:10000,custmid:100&#125;, to:"shard1"&#125;) PS：一般执行命令都有这两种方式 sh. 方式可以不用切换数据库执行 db. 方式必须在admin数据库下PS：迁移条件必须包含片键 3、 查看迁移情况12use configdb.chunks.find(&#123;"_id":/customer.info-did_10000*/, "ns":"customer.info"&#125;).pretty() 也可以关注下主备切换的日志情况1find / -name mongo*.log（找到各mongo进程log） 五、 chunk分裂1、 查看chunk分裂前情况12use configdb.chunks.find(&#123;"_id":/customer.info-did_10000*/, "ns":"customer.info"&#125;).pretty() 2、 指定分裂点1sh.splitAt("customer.info", &#123;"did":10000, "custmid":500&#125;) 3、 检查分裂情况1db.chunks.find(&#123;"_id":/customer.info-did_10000*/, "ns":"customer.info"&#125;).pretty() 六、 其他1、 重启moa服务PS：因为有的服务可能有缓存，所有在操作了数据库之后需要重启服务才能重新读取数据库数据 2、 检查各模块功能情况PS：因为涉及到php、go、c的mongo库，所以需要覆盖以下测试 web端、PC端、运营、统计 主要关注点——涉及数据库读写操作的功能——大量读写操作情况——导入导出情况——私有云服务器接入情况——数据删除情况——数据恢复情况 3、 检查服务器资源情况PS：可以写一个小的脚本（超过一定的阈值则输出到log里面），然后一直在后台运行，然后操作业务最后测试完之后，检查log文件中的资源记录情况]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[App三方交互逻辑实践]]></title>
      <url>%2F2016%2F11%2F16%2FApp%E4%B8%89%E6%96%B9%E4%BA%A4%E4%BA%92%E9%80%BB%E8%BE%91%E5%AE%9E%E8%B7%B5%2F</url>
      <content type="text"><![CDATA[项目地址：https://github.com/tunsuy/AppInteractive 一、 背景介绍之前有一个公司项目与第三方应用交互的逻辑需要全面测试，那么怎样才能测试到整个交互的所有环节呢 那就是需要一个实际的第三方，并且这个第三方需要包括server端和app端 既然是测试，那么我们只需要将公司项目跟三方有交互的接口做个全面的测试即可，不在乎这个三方是怎样的形式 那么这就好办了，自己实现一个这个的三方项目 二、 交互逻辑图1、口袋助理跳转第三方app逻辑示意图： 2、第三方跳转口袋助理逻辑示意图： 三、 实现server端：go语言实现app端：iOS 具体实现见github项目地址 根据相关协议从代码层面详细的测试每个交互接口： 兼容性 容错性 健壮性]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mongodb集群3.0.X升级3.2.X]]></title>
      <url>%2F2016%2F10%2F15%2Fmongodb%E9%9B%86%E7%BE%A43-0-X%E5%8D%87%E7%BA%A73-2-X%2F</url>
      <content type="text"><![CDATA[一、 简介该文章主要根据官方英文文档来操作的 官方文档：https://docs.mongodb.com/manual/release-notes/3.2-upgrade/ 二、 升级准备工作1、下载二进制文件1wget https://www.mongodb.com/dr/fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel62-3.2.10.tgz 2、将该文件放入所有的节点服务器下并解压1tar -zxvf XXXX 3、备份configdb（可选）在每个configdb服务器执行：1cp -r /home/moa/db/configdb/data/ /home/moa/db/configdb/data_bak/ 4、关闭均衡器 查看均衡器状态: sh.getBalancerState() 关闭: sh.stopBalancer() 检查数据没有在迁移12345use configwhile( sh.isBalancerRunning() ) &#123; print("waiting..."); sleep(1000);&#125; 三、 开始升级1、 首先升级分片01.1 升级分片0集群中的secondary节点 停掉该mongod0进程—kill pid 使用最新mongodb进程替换掉mongod0 12345#备份：mv /usr/local/mongodb/bin/mongod0 /usr/local/mongodb/bin/mongod0.bak #替换：cp /home/mongodb-linux-x86_64-rhel62-3.2.10/bin/mongod /usr/local/mongodb/bin/mongod0 启动该mongod0进程—/etc/init.d/mongod0 restart 按照1.1方法依次升级其他的secondary节点ps：在确认上一个secondary状态正常的情况再进行: rs.status() 1.2 升级分片0集群中的primary节点 停掉primary—rs.stepDown() 检查是否产生了新的primary—rs.status()ps：在其他两个节点查看 按照1的方法升级其他分片 1.3 更新选举协议在primary节点执行以下操作：123cfg=rs.conf();cfg.protocolVersion=1;rs.reconfig(cfg); 2、 升级分片1按照1中的方法进行 3、 升级config 服务器 顺序：需要按照mongos中配置的逆序升级12cat /home/moa/db/mongos/mongos.conf——configdb=config0.moadb.com,config1.moadb.com,config2.moadb.com 所以升级顺序应该是：config2、config1、config0 升级：按照1中方法进行（只是这里变成了mongocfgd） 4、 升级mognos服务器按照1中方法进行（只是这样换成了mongos） 5、 替换掉所以的mongo工具（可选）1cp ./mongodb-linux-x86_64-rhel62-3.2.10/bin/* /usr/local/mongodb/bin/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[深入理解Java中的线程安全和集合]]></title>
      <url>%2F2016%2F10%2F09%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E9%9B%86%E5%90%88%2F</url>
      <content type="text"><![CDATA[翻译于http://www.codejava.net/java-core/collections/understanding-collections-and-thread-safety-in-java 注：不是原文翻译，有些自己的理解改动 一、 简介为什么大部分的collection类都是线程不安全的呢？正如你知道的，大部分的collection类如：ArrayList、LinkedList、HashMap、HashSet、TreeMap、TreeSet 等等都是线程不安全的。事实上，在 java.util 包中的所有collection类（除了 Vector 和 HashTable ）都是线程不安全的。为什么呢？ 原因：同步的代价是很大的。 Vector 和HashTable 是java早期就存在的两个集合，他们一开始就被设计为线程安全的（如果你看源码，你会发现他们的所有方法都是 synchronized 的）。然而，很快在多线程程序中它们就被暴露出性能是很低下的，因为同步是需要加锁的，这很耗性能。 这也是为什么在后来新的collections( List、Set、Map 等)都提供了在单线程应用中非并发性的控制来获得最大的性能。 下面的程序比较了 Vector 和 ArrayList 的性能（ Vector 是线程安全的，而 ArrayList 不是）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.util.*;/** * This test program compares performance of Vector versus ArrayList * @author www.codejava.net * */public class CollectionsThreadSafeTest &#123; public void testVector() &#123; long startTime = System.currentTimeMillis(); Vector&lt;Integer&gt; vector = new Vector&lt;&gt;(); for (int i = 0; i &lt; 10_000_000; i++) &#123; vector.addElement(i); &#125; long endTime = System.currentTimeMillis(); long totalTime = endTime - startTime; System.out.println("Test Vector: " + totalTime + " ms"); &#125; public void testArrayList() &#123; long startTime = System.currentTimeMillis(); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10_000_000; i++) &#123; list.add(i); &#125; long endTime = System.currentTimeMillis(); long totalTime = endTime - startTime; System.out.println("Test ArrayList: " + totalTime + " ms"); &#125; public static void main(String[] args) &#123; CollectionsThreadSafeTest tester = new CollectionsThreadSafeTest(); tester.testVector(); tester.testArrayList(); &#125;&#125; 该程序测试了分别给这两种类型增加1000000个元素所耗费的时间，结果如下：12Test Vector: 9266 msTest ArrayList: 4588 ms 说明在大数据量下，ArrayList的性能比Vector的好两倍以上。 二、 快速失败快速失败又叫做”Fail-Fast“策略。当使用集合时，你需要理解它们的迭代器的并发策略：Fail-Fast Iterators 看下面的代码片段：Strings列表的迭代12345678List&lt;String&gt; listNames = Arrays.asList("Tom", "Joe", "Bill", "Dave", "John");Iterator&lt;String&gt; iterator = listNames.iterator();while (iterator.hasNext()) &#123; String nextName = iterator.next(); System.out.println(nextName);&#125; 这里我们使用了集合的迭代器来遍历集合元素。加入listNames是被两个线程所共享：正在迭代遍历的目前的线程和另外一个线程。当第一个线程正在迭代遍历的时候，第二个线程也在修改这个集合（增加或者减少元素）。那么结果会怎样呢？ 第一个线程将抛出这个异常 ConcurrentModificationException并立刻失败。所以这就叫做 fail-fast iterators。 迭代器为什么会这么快的失败呢？这是因为当遍历一个正在修改的集合时是非常危险的：这个迭代器被生成之后，这个集合可能有更多、更少或者没有元素，以至于导致无法预期或者不一致的结果。这应该要尽可能早的避免，因此这个迭代器必现抛出一个异常来结束目前线程的执行。 下面的例子模拟了抛出 ConcurrentModificationException 异常的情况：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.util.*;/** * This test program illustrates how a collection's iterator fails fast * and throw ConcurrentModificationException * @author www.codejava.net * */public class IteratorFailFastTest &#123; private List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); public IteratorFailFastTest() &#123; for (int i = 0; i &lt; 10_000; i++) &#123; list.add(i); &#125; &#125; public void runUpdateThread() &#123; Thread thread1 = new Thread(new Runnable() &#123; public void run() &#123; for (int i = 10_000; i &lt; 20_000; i++) &#123; list.add(i); &#125; &#125; &#125;); thread1.start(); &#125; public void runIteratorThread() &#123; Thread thread2 = new Thread(new Runnable() &#123; public void run() &#123; ListIterator&lt;Integer&gt; iterator = list.listIterator(); while (iterator.hasNext()) &#123; Integer number = iterator.next(); System.out.println(number); &#125; &#125; &#125;); thread2.start(); &#125; public static void main(String[] args) &#123; IteratorFailFastTest tester = new IteratorFailFastTest(); tester.runIteratorThread(); tester.runUpdateThread(); &#125;&#125; 代码中，这个 thread1 正在迭代遍历 list，而 thread2 也在继续增加元素到这个集合，这就导致了 ConcurrentModificationException 抛出。 注意：迭代器的 fail-fast 行为只是用来帮助更容易的找到或者诊断bug，我们不应该在程序中依赖并操作这个 ConcurrentModificationException 因为 fail-fast 不被保障的。这就是说当这个异常抛出后，我们的程序应该立即停止运行。 三、 同步装饰器1、 简介目前我们已经知道了这些基本的集合类的实现都是线程不安全的，是为了最大的提高在单线程程序中的性能。那么如果我们要用在多线程应用中呢？ 当然我们不应该在并发的上下文中使用线程不安全的集合类，因为这将导致无法预期和不一致的结果。我们可以通过同步代码块来手动的控制我们的代码。然而使用线程安全的集合类总是比我们手动写同步代码块是更好的。 可能你已经知道的，Java的 Collections 库给我们提供了创建线程安全的集合的工厂方法。这些方法就是来自下面的形式：1Collections.synchronizedXXX(collection) 这些工厂方法装饰指定的集合，然后返回线程安全的实现。这里的 XXX 可以是 Collection, List, Map, Set, SortedMap 和 SortedSet。下面就是一个例子：1List&lt;String&gt; safeList = Collections.synchronizedList(new ArrayList&lt;&gt;()); 如果我们已经有一个存在的线程不安全的集合对象，我们也可以使用这个来装饰它：12Map&lt;Integer, String&gt; unsafeMap = new HashMap&lt;&gt;();Map&lt;Integer, String&gt; safeMap = Collections.synchronizedMap(unsafeMap); 这些工厂方法都是以一个相同的接口实现了对指定的集合的线程安全实现的装饰，所以叫做 &#39;synchronized wrappers&#39;。实际上，就是这些线程不安全的集合将所有的工作都委托给了这个装饰器集合来处理。 2、 注意当使用一个同步集合的迭代器的时候，我们需要使用同步块来保证迭代器的安全，因为这个迭代器不是线程安全的。看下面的例子：12345678910List&lt;String&gt; safeList = Collections.synchronizedList(new ArrayList&lt;&gt;());// adds some elements to the listIterator&lt;String&gt; iterator = safeList.iterator();while (iterator.hasNext()) &#123; String next = iterator.next(); System.out.println(next);&#125; 虽然 safeList 是线程安全的，但是他的迭代器不是，因此我们需要手动增加同步块：123456synchronized (safeList) &#123; while (iterator.hasNext()) &#123; String next = iterator.next(); System.out.println(next); &#125;&#125; 同样的需要注意：同步集合的迭代器也是 fail-fast 的。 虽然同步装饰器可以安全的用在多线程应用中，但是有一些缺点需要说明，在下面将介绍 四、 并发集合1、 简介同步集合的一个缺点就是它们的同步机制是使用的它们自己作为锁对象。这就意味着一个线程正在遍历这个集合的时候，在这个集合其他方法块的其他线程就得等待，这就导致程序性能下降。 这就是为什么说Java5及以上介绍说 concurrent collections(并发集合)的性能比同步装饰器好。并发集合是在 java.util.concurrent 包中。它们根据它们的线程机制被分为了三个组。 2、 copy-on-write collections第一个组叫 copy-on-write collections ：这种线程安全的集合是在不可变的数组中存储值的；这个集合的值的任何改变，结果都是返回一个新的数组用来反射到新的值； 这种集合适合于读操作远远多于写操作的情况；有两种实现：CopyOnWriteArrayList 和 CopyOnWriteArraySet。 注意：这种集合有一个 iterators 快照，不会抛出 ConcurrentModificationException 异常。因为这种集合是基于不可变数组的，所以一个线程能够读取集合中的数据而不用担心其他线程改变了它们。 3、 CAS collections第二组叫 Compare-And-Swap or CAS collections：这组集合是基于 Compare-And-Swap (CAS) 算法实现的线程安全。CAS算法是这样的： 为了执行计算或者更新变量的值，它对变量在本地做了一份复制，计算的时候使用的是这个本地的值。当它想要更新这个变量的值时，它会用本地的值跟这个变量进行对比，如果它们是相同的，则用新的值更新这个变量。 如果它们是不相同的，那么说明这个变量被其他线程改变了，这种情况下，CAS 线程会尝试使用这个新值进行计算，或者放弃，或者继续。CAS 包括 ConcurrentLinkedQueue 和 ConcurrentSkipListMap。 注意：CAS 集合的迭代器是弱一致性的。就是指它可能只会反射这个集合中的一些而不是所有的变化。弱一致性不会抛出 ConcurrentModificationException。 4、 special lock object第三组叫 concurrent collections using a special lock object (java.util.concurrent.lock.Lock)：这个机制是比经典的同步机制更加的灵活。 这个锁跟经典的同步有相同的行为，但是一个线程在以下几种情况也能够获取它：锁目前不被持有，超时或者线程没有被中断。 不同于同步代码，一个锁对象在代码块或者方法被执行的时候就被持有。而这个 lock 是在 unlock() 方法被调用时才持有。这个机制很有用的一些实现就是将集合分成部分，从而可以分别持有。为了提高并发，比如 LinkedBlockingQueue ，这个队列的头和尾被分开 lock，因此这个元素能够并行的增减。 一些集合使用包含 ConcurrentHashMap 的锁和 BlockingQueue 的大部分实现。 这个组中的集合也是弱一致性的迭代器，不会抛出 ConcurrentModificationException。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[redmine-数据统计]]></title>
      <url>%2F2016%2F10%2F08%2Fredmine-%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%2F</url>
      <content type="text"><![CDATA[一、 项目说明语言：python语言 1、项目地址：https://github.com/tunsuy/redmine_statis 2、统计维度： 个人迭代bug数 模块迭代bug数 个人网上问题数 个人迭代工作粒度 个人遗留问题数 如果要加上其他维度的统计，也是非常简单的 二、 redmine表说明1、表issues—用来存放issue的标准字段。 2、表custom_fields—该表字段都和创建自定义字段的web页面看到的选择项很像。 3、表custom_values—该表可以用custom_field_id字段和custom_fields表的id关联。 而customized_id 可以和issues表的id相关联 三、 表关联1、三个表issues, custom_fields和custom_values在一起表达了这么个关系。 2、一个issue的标准字段来自issues表，扩展字段来自custom_fields表，而custom_values和前custom_fields表关联，一起表示一个issue的某个自定义字段的值。 3、当表示issue的自定义字段时，custom_fields.type的值是 ‘IssueCustomField’ 而custom_values.customized_type的值是’Issue’. 4、所有issue的自定义字段值可以先将custom_fields表和custom_values表关联，获得如下结果：1select customized_id as issue_id,custom_field_id,type,name,default_value,value from custom_fields a inner join custom_values b on a.id =b.custom_field_id and a.type = 'IssueCustomField' and b.customized_type='Issue' limit 2; 由此可以看出redmine的设计是用记录行数来表示扩展字段的值，所以可以不受mysql表字段的限制。 四、 访问权限基本知识了解：1、授予用户redmine_static 在指定ip下 以 密码 moatest 访问 bitnami_redmine 的 select和excute操作1grant select,excute on bitnami_redmine.* to 'redmine_static'@'200.200.169.162' identified by 'moatest' 2、查询mysql所有用户1select user,host,password from mysql.user; 3、刷新权限设置1flush privileges; 4、查询 指定IP 下 用户redmine_static 的数据库权限1show grants for 'redmine_static'@'200.200.169.162'\G 5、取消用户的操作权限1revoke select on bitnami_redmine.* from 'redmine_static'@'200.200.169.162' identified by 'moatest'; 6、授予所有操作权限1grant all privileges on bitnami_redmine.* to 'redmine_static'@'200.200.169.162' identified by 'moatest'; 7、删除用户1drop user redmine_static@'%'; 8、创建用户1create user redmine_static@'%' identified by 'moatest'; 五、 redmine统计说明1、在redmine服务器中新增一个mysql用户：——该用户只能在169.162中以用户名和密码的方式访问——见如上2说明 六、 使用1、切换python环境：pyenv activate venv27102、切换到项目路径3、执行：python main.py [统计开始时间 统计结束时间]1eg：python main.py 2016-9-1 2016-12-31]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[实现浏览器中实时查看iOS日志]]></title>
      <url>%2F2016%2F09%2F23%2F%E5%AE%9E%E7%8E%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E5%AE%9E%E6%97%B6%E6%9F%A5%E7%9C%8BiOS%E6%97%A5%E5%BF%97%2F</url>
      <content type="text"><![CDATA[项目地址：https://github.com/tunsuy/TSiOSLogWebBrowser 一、 背景在测试ios App过程中，有很多时候我们需要一边操作一遍查看输出日志 对于有mac机的来说，当然在xcode下自己打包测试查看日志那是非常方便的，但是大部分的测试是没有mac机的。 虽然开发也有将日志写入文件，但是每次操作完了再去打开文件查看，非常不方便 那有没有一种类似xcode输出日志的方式呢答案就是今天要说的这个： 直接用浏览器实时查看输出的log信息 二、 原理就是在app里面内置一个http server服务器，浏览器作为请求客户端，将app的操作日志实时的输出到浏览器中。 三、 实现使用了一个开源框架 GCDWebServer 作为http server具体实现见github项目地址 四、 使用1、将手机置于电脑的同一网络， 2、然后在浏览器上输入 手机IP：port（端口是在代码中任意指定的），然后就可以开始测试app了，你将会看到浏览器中会实时显示你的操作日志出来，跟xcode下查看日志的方式一样， 注：浏览器页面支持 跟随日志自动滚动 ；非常方便 五、 效果图]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[代码扫描之API调用版本检查]]></title>
      <url>%2F2016%2F09%2F18%2F%E4%BB%A3%E7%A0%81%E6%89%AB%E6%8F%8F%E4%B9%8BAPI%E8%B0%83%E7%94%A8%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5%2F</url>
      <content type="text"><![CDATA[一、 项目简介语言：python语言 该项目是对工程项目代码进行全面扫描，发现其是否有代码层面的bug目前第一版支持了ios下的api版本控制的扫描检查后续将逐渐支持其他方面的代码检查，比如是否有内存溢出，数组越界等，支持检查项可配置 完整的项目源码地址：https://github.com/tunsuy/iOS-code-scan 该项目现已很好的服务于公司的ios项目代码扫描中，有效的检测出很多开发人员疏忽的api版本使用问题 下面只对api版本控制检查进行实现讲解 二、 实现思路扫描ios项目，将所有的api方法原型依次提取出来，跟ios官方定义的版本进行比对；检查对那些有版本限制的api，在代码中是否有相应的条件判断 那么这就涉及到如下几个问题1、需要知道ios库中所有的api版本信息情况2、需要提取出代码中所有的api调用并重新组装成方法原型3、需要知道该方法原型调用是否在相应的条件判断中4、条件判断可能是多层嵌套的5、方法调用可能特别复杂，跨度可能特别大6、方法调用可能是多层嵌套的 三、 解决方案如下1、使用爬虫将ios库的api版本信息抓取下来，并存储在数据库中——主要定义三个表：framework、class、api2、逐个文件逐行扫描，以方法调用的固有特征（比如：[class1 fun_1.1:[class2 fun_2] fun_1.2:xx]），提取出方法原型——当然要完整的一个不漏的提取出所有方法，处理逻辑还是很复杂的3、根据方法原型读取api数据库，获取其对应的sdk版本4、如果有版本限制，则检查其是否处于条件判断中——需要保持条件判断的上下文信息，多层if嵌套的匹配等 四、 使用技术爬虫：使用了python的scrapy框架备注：12345678910#创建一个爬虫项目scrapy startproject ScrapyIOSAPI#shell调试方法scrapy shell "https://developer.apple.com/reference?language=objc" #调试举例:response.xpath('//div[@class="task-symbols"]/div[@class="symbol clm"]/a/code/text()')scrapy crawl spider_name—执行爬虫 数据库：sqlite轻量级数据库 整个项目采用Python实现： 数据库连接技术 多线程技术 抽象类和类继承、生成器等高级技术 五、 工程介绍该工程包括两个项目 1、 爬虫项目爬取所有的苹果官方object-c下的API相关信息，并保存在数据库中使用 切换到工程下的iOSAPI目录下 执行scrapy crawl objcApi会在当前目录下生成IOSAPI.db数据库文件该数据库保存了所有API的相关信息 2、 扫描iOS项目支持扫描单个文件或者项目目录，根据自己输入的参数决定使用 切换到工程下的scan_proj目录下 执行python main.py 需要扫描的项目路径 结果保存文件注：路径可以是单个文件名或者项目目录 六、 对ios代码规范的建议对于版本控制，统一使用宏定义代码不要一行写多条语句，尽量按照ios开发规范来写代码]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java：重温数据结构-链表]]></title>
      <url>%2F2016%2F09%2F13%2FJava%EF%BC%9A%E9%87%8D%E6%B8%A9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%2F</url>
      <content type="text"><![CDATA[翻译于https://www.cs.cmu.edu/~adamchik/15-121/lectures/Linked%20Lists/linked%20lists.html 注：不是原文翻译，有些自己的理解改动 一、 引言一个链表就是一个线性的数据结构，如下图所示： 一个链表中的每个元素（我们叫它节点）包含两个部分-数据和指向下一个节点的引用，最后一个节点的引用部分则指向null。指向链表的一个对象（实体）叫做这个链表的head（头部），这个head不是链表中一个独立的节点，但它是指向链表的第一个节点。如果链表为空，head则表示一个空的引用。 链表是一个动态的数据结构，链表中节点的数量不是固定的，能够根据需要动态的增减。如果一个应用需要处理的对象（实体）数是不确定的，则需要使用链表来表示。 链表相对于数组来说的一个缺点就是不允许直接访问其中的元素。如果你想要访问一个指定的元素，你必须从链表的head开始，依次找到它的下一个引用，直到你得到这个想要的元素。 链表的另外一个缺点就是比数组占用更多的内存空间。因为需要使用额外的空间保存下一个节点引用（next）。 二、 链表的类型1、单链表，就是上面描述的2、双向链表，就是指一个链表有两个引用，一个指向下一个节点，另一个指向前一个节点，如图 链表的另一个重要的类型叫循环链表，就是指链表的最后一个节点指向链表的第一个节点（或者head）。 三、 节点类java语言中，你可以定义一个类（B）被包含于另一个类（A）。类A叫做外部类，类B叫做内部类。内部类的作用仅仅就是用于内部帮助类。下面就是链表内部节点类的定义1234567891011private static class Node&lt;AnyType&gt;&#123; private AnyType data; private Node&lt;AnyType&gt; next; public Node(AnyType data, Node&lt;AnyType&gt; next) &#123; this.data = data; this.next = next; &#125;&#125; 一个内部类就是外部类的一个成员，能够访问外部类的其他成员（包括私有成员）。反之亦然，外部类也能够访问内部类的所有成员。一个内部类能够被private、public、protected或者package访问权限修饰。有两种内部类：静态和非静态的。 这里我们使用两个内部类来实现链表：静态 Node 类和非静态 LinkedListIterator 。完整的实现请看 LinkedList.java 四、 例子让我们分段的来跟踪每一步的影响，在每一步执行之前，链表存储它的初始状态。 1head = head.next; 1head.next = head.next.next; 1head.next.next.next.next = head; 五、 链表操作1、 addFirst这个方法创建一个节点，并放在链表的开始位置，如图： 1234public void addFirst(AnyType item)&#123; head = new Node&lt;AnyType&gt;(item, head);&#125; 2、 Traversing从head开始，访问每一个节点，直到null，不改变head的引用。如图： 123Node tmp = head;while(tmp != null) tmp = tmp.next; 3、 addLast这个方法增加一个节点到链表的最后，这需要 Traversing ，但确保在最后一个节点的时候停止。如图： 1234567891011public void addLast(AnyType item)&#123; if(head == null) addFirst(item); else &#123; Node&lt;AnyType&gt; tmp = head; while(tmp.next != null) tmp = tmp.next; tmp.next = new Node&lt;AnyType&gt;(item, null); &#125;&#125; 4、 Inserting “after”找到指定key的节点，然后在它之后插入一个节点。如下图所示，我们在”E”之后插入一个新的节点。 12345678public void insertAfter(AnyType key, AnyType toInsert)&#123; Node&lt;AnyType&gt; tmp = head; while(tmp != null &amp;&amp; !tmp.data.equals(key)) tmp = tmp.next; if(tmp != null) tmp.next = new Node&lt;AnyType&gt;(toInsert, tmp.next);&#125; 5、 Inserting “before”找到指定key的节点，然后在它之前插入一个节点。如下图所示，我们在”A”之前插入一个新的节点。 为了方便起见，我们增加两个引用 pre 和 cur，保证 pre 在 cur 之前。同时平移这两个引用，直到 cur 到达我们想要插入的节点之前。如果 cur 到达null，则不插入，否则我们插入一个新的节点在 pre 和 cur 之间。1234567891011121314151617181920public void insertBefore(AnyType key, AnyType toInsert)&#123; if(head == null) return null; if(head.data.equals(key)) &#123; addFirst(toInsert); return; &#125; Node&lt;AnyType&gt; prev = null; Node&lt;AnyType&gt; cur = head; while(cur != null &amp;&amp; !cur.data.equals(key)) &#123; prev = cur; cur = cur.next; &#125; //insert between cur and prev if(cur != null) prev.next = new Node&lt;AnyType&gt;(toInsert, cur);&#125; 6、 Deletion找到指定key的节点并删除它。如下图所示删除包含”A”的节点。 这个方法的算法和前一个很相似。为了方便起见，我们增加两个引用 pre 和 cur，保证 pre 在 cur 之前。同时平移这两个引用，直到 cur 到达我们想要删除的节点。这里有三种情况需要注意：1、链表为空2、删除的是head节点3、需要删除的节点不再链表中123456789101112131415161718192021222324public void remove(AnyType key)&#123; if(head == null) throw new RuntimeException("cannot delete"); if( head.data.equals(key) ) &#123; head = head.next; return; &#125; Node&lt;AnyType&gt; cur = head; Node&lt;AnyType&gt; prev = null; while(cur != null &amp;&amp; !cur.data.equals(key) ) &#123; prev = cur; cur = cur.next; &#125; if(cur == null) throw new RuntimeException("cannot delete"); //delete cur node prev.next = cur.next;&#125; 7、 Iterator迭代器提供了对集合数据的访问方式，隐藏集合数据的内部表示形式。在java中迭代器是一个对象，因此需要创建一个类来实现，并且这个类需要实现 Iterator 接口。通常这样的类是作为一个内部类来实现的。iterator 接口包含下面三个方法：1、AnyType next() - 返回容器中的下一个元素2、boolean hasNext() - 检查是否还有下一个元素3、void remove() - (可选的操作).移除通过 next() 方法返回的元素 下面讲讲 LinkedList 类中的 iterator 实现。首先我在 LinkedList 中增加一个方法：1234public Iterator&lt;AnyType&gt; iterator()&#123; return new LinkedListIterator();&#125; 下面 LinkedListIterator 是 LinkedList 的一个私有内部类12345678910private class LinkedListIterator implements Iterator&lt;AnyType&gt;&#123; private Node&lt;AnyType&gt; nextNode; public LinkedListIterator() &#123; nextNode = head; &#125; ...&#125; LinkedListIterator 类 必须实现 next() 和 hasNext() 方法.1234567public AnyType next()&#123; if(!hasNext()) throw new NoSuchElementException(); AnyType res = nextNode.data; nextNode = nextNode.next; return res;&#125; 六、 Cloning克隆就像任何其他一个对象一样，我们需要学习怎样clone一个链表。如果我们简单的使用 Object 类的 clone() 方法，那么就是”浅复制”，如下图所示： 这个Object的 clone() 方法只会对第一个节点进行一份内容复制，其他节点都是引用复制，内容共享。这显然不是我们想要的效果，那么看看下面的”深复制” 有几种方法可以”深复制”链表，一种简单的方法就是遍历每一个节点，然后使用 addFirst() 方法。最后你将得到一个倒序的新的链表，然后我们不得不反转这个链表。123456789101112public Object copy()&#123; LinkedList&lt;AnyType&gt; twin = new LinkedList&lt;AnyType&gt;(); Node&lt;AnyType&gt; tmp = head; while(tmp != null) &#123; twin.addFirst( tmp.data ); tmp = tmp.next; &#125; return twin.reverse();&#125; 一个更好的方法就是对这个新链表使用尾引用，在最后的节点增加每一个新节点。1234567891011121314151617public LinkedList&lt;AnyType&gt; copy3()&#123; if(head==null) return null; LinkedList&lt;AnyType&gt; twin = new LinkedList&lt;AnyType&gt;(); Node tmp = head; twin.head = new Node&lt;AnyType&gt;(head.data, null); Node tmpTwin = twin.head; while(tmp.next != null) &#123; tmp = tmp.next; tmpTwin.next = new Node&lt;AnyType&gt;(tmp.data, null); tmpTwin = tmpTwin.next; &#125; return twin;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python：iterator pattern—迭代器模式]]></title>
      <url>%2F2016%2F08%2F18%2FPython%EF%BC%9Aiterator-pattern%E2%80%94%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[翻译于https://davidcorne.com/2013/02/22/iterator-pattern/ 注：不是原文翻译，有些自己的理解改动 该文章主要从python语言的角度去讲解 一、 目的这个模式背后的意思是：有一个对象，你能够循环它而不需要知道这个对象数据的内部表现。在Python这门语言中，没有什么是私有的（译者注：python中的访问控制是约定），你能够找到一个类的内部构成，这个迭代器模式给了你一个标准的接口。 我认为在python中一个iterator最好的例子就是使用list，因此这里我确定你已经知道怎么使用这个list了 123list = ["one", "two", "three"]for number in list: print(number) 这将得到下面的输出：123onetwothree 在python中这个模式的目标就是为了让用户自定义的类也能够像这样使用。 二、 模式这是十分轻量的一个模式，因此我将主要关注实现细节而不是设计。下面是这个设计模式的UML类图 从上图可以看出，iterator通过组合的方式持有一个容器类实例，它不拥有/删除这个容器本地，只是对这个容器实例的一个引用。 你能看到我们这里是在谈论一般的集合数据结构而不是特指一个list或者dictionary。这些集合类的这些方法是为了定义一个集合/迭代器的接口，接下来我将详细的介绍它们。 三、 python协议协议是python中给出的名字（译者注：OC语言中也有协议这个说法），是你定义某一类对象的接口。它不像接口那样是一个正式的需要。它只是一个指导性作用。 它们主要集中在魔术方法，就是那些名字前后是”–”的方法。 我将简单的谈论下可变和不可变容器或者迭代器中的协议。 1、 不可变容器不可变容器是指你不能修改容器中元素项，只能获取它们长度或者获取其中的元素项。 下面是不可变容器中的魔术方法123456789def __len__(self): """ Returns the length of the container. Called like len(class) """def __getitem__(self, key): """ Returns the keyth item in the container. Should raise TypeError if the type of the key is wrong. Should raise KeyError if there is no item for the key. Called like class[key] """ 2、 可变容器正如你期望的，一个可变容器跟不可变容器有一样的获取方法，另外还有setting和adding方法。 下面是这些魔术方法：12345678910111213141516171819202122232425262728def __len__(self): """ Returns the length of the container. Called like len(class) """def __getitem__(self, key): """ Returns the keyth item in the container. Should raise TypeError if the type of the key is wrong. Should raise KeyError if there is no item for the key. Called like class[key] """def __setitem__(self, key, value): """ Sets the keyth item in the container. Should raise TypeError if the type of the key is wrong. Should raise KeyError if there is no item for the key. Called like class[key] = value """def __delitem__(self, key): """ Deletes an item from the collection. Should raise TypeError if the type of the key is wrong. Should raise KeyError if there is no item for the key. Called like del class[key] """ 对于一个不可变容器，你可能也想要有一些方法来增加容器中的元素，对于list/array这类的容器，这些方法可能形如 append(self, key)，或者对于dictionary/table这类容器，则可能是形如 __setitem__(self, key, value) 你也可以增加其他的一些方法，比如 __reversed__(self) 和 __contains__(self, item)，但这些对于核心方法族不是必须的。这儿是更好的描述here 3、 iterator迭代器一个迭代器的协议是非常简单的。1234567891011def __iter__(self): """ Returns an iterator for the collection. Called like iter(class) or for item in class: """def next(self): """ Returns the next item in the collection. Called in a for loop, or manually. Should raise StopIteration on the last item. """ 这个iter方法通常返回一个迭代器对象或者返回它自己。注意在python3中 next() 被重命名为了 __next__() 四、 一个例子使用这里是一个例子告诉你怎么实现一个简单的迭代器，这个例子是循环来反转一个集合。12345678910111213141516171819202122#==============================================================================class ReverseIterator(object): """ Iterates the object given to it in reverse so it shows the difference. """ def __init__(self, iterable_object): self.list = iterable_object # start at the end of the iterable_object self.index = len(iterable_object) def __iter__(self): # return an iterator return self def next(self): """ Return the list backwards so it's noticeably different.""" if (self.index == 0): # the list is over, raise a stop index exception raise StopIteration self.index = self.index - 1 return self.list[self.index] 注意这里仅仅定义了迭代器协议所需要的两个方法。 这些方法的意思很明显了，构造函数 (__init__) 引用了一个可迭代对象，并且保持了这个可迭代对象的长度作为 index。这个 __iter__ 返回它自己，因为它已经定义了一个 next() 方法。这个 next() 方法对 index 递减，然后返回这个元素项，除非没有元素项了，就抛出一个 StopIteration 异常 在这个例子中，这个 ReverseIterator 迭代器对象被 Days 对象使用。代码如下：12345678910111213141516#==============================================================================class Days(object): def __init__(self): self.days = [ "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday" ] def reverse_iter(self): return ReverseIterator(self.days) 这个类仅仅是对一周的日期list的装饰器，有一个公开的方法返回一个迭代器。 下面的代码显示了怎么使用 Days 类。12345#==============================================================================if (__name__ == "__main__"): days = Days() for day in days.reverse_iter(): print(day) 注：我也能够定义一个 __iter__ 方法代替 reverse_iter() 方法，然后就可以像下面这样使用了：12345#==============================================================================if (__name__ == "__main__"): days = Days() for day in days: print(day) 都将正确的输出下面的结果：1234567SundaySaturdayFridayThursdayWednesdayTuesdayMonday 这部分的代码可以在这个文件找到this file 下面是这些类的UML类图 这篇文章所以得代码都能在这里找到here 感谢你的阅读]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS：性能之卡顿检测]]></title>
      <url>%2F2016%2F08%2F11%2Fios%EF%BC%9A%E6%80%A7%E8%83%BD%E4%B9%8B%E5%8D%A1%E9%A1%BF%E6%A3%80%E6%B5%8B%2F</url>
      <content type="text"><![CDATA[一、 项目简介项目地址：https://github.com/tunsuy/iOSMonitorLag 该项目主要是针对ios项目的卡顿监控的探索，结合ios的运行机制和业界的实践，将其应用于公司项目中进行试运行，查看相关效果 二、 方案一 基于RunLoop1、 背景 因为UIKit本身的特性,需要将所有的UI操作都放在主线程执行,所以也造成不少程序员都习惯将一些线程安全性不确定的逻辑,以及其它线程结束后的汇总工作等等放到了主线,所以主线程中包含的这些大量计算、IO、绘制都有可能造成卡顿. 在Xcode中已经集成了非常方便的调试工具Instruments,它可以帮助我们在开发测试阶段分析软件运行的性能消耗 2、 原理 监控卡顿,最直接就是找到主线程都在干些啥玩意儿.我们知道一个线程的消息事件处理都是依赖于NSRunLoop来驱动,所以要知道线程正在调用什么方法,就需要从NSRunLoop来入手 发现NSRunLoop调用方法主要就是在kCFRunLoopBeforeSources和kCFRunLoopBeforeWaiting之间,还有kCFRunLoopAfterWaiting之后,也就是如果我们发现这两个时间内耗时太长,那么就可以判定出此时主线程卡顿. 3、 缺点这种方式，当主线程中注册了timer等很多附加的东西时，会不断唤醒主线程，就会大量的调用observer回调，造成一定程度上的性能损耗 三、 方案二 基于线程1、 背景简单来说，主线程为了达到接近60fps的绘制效率，不能在UI线程有单个超过（1/60s≈16ms）的计算任务。通过Instrument设置16ms的采样率可以检测出大部分这种费时的任务，但有以下缺点： Instrument profile一次重新编译，时间较长。 只能针对特定的操作场景进行检测，要预先知道卡顿产生的场景。 每次猜测，更改，再猜测再以此循环，需要重新profile。我们的目标方案是，检测能够自动发生，并不需要开发人员做任何预先配置或profile。运行时发现卡顿能即时通知开发人员导致卡顿的函数调用栈。 2、 原理 最理想的方案是让UI线程“主动汇报”当前耗时的任务，听起来简单做起来不轻松。 我们可以假设这样一套机制：每隔16ms让UI线程来报道一次，如果16ms之后UI线程没来报道，那就一定是在执行某个耗时的任务。 下面是以接入口袋助理测试的效果图 四、 最后但是像在口袋助理这样大型负责的项目中，这些方法都存在一些弊端，监测出来的也不一定是真的由于代码问题引起的，这只是可以作为一种自动提醒机制，让开发者自行去检查下提示的代码是否真的存在性能缺陷]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python：builder pattern—建造者模式]]></title>
      <url>%2F2016%2F08%2F11%2FPython%EF%BC%9Abuilder-pattern%E2%80%94%E5%BB%BA%E9%80%A0%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[翻译于https://davidcorne.com/2013/01/21/builder-pattern/ 注：不是原文翻译，有些自己的理解改动 一、 目的builder设计模式（以下均称建造者模式）的意思是指一个对象的构造是抽象的，以便于许多的实现能够使用相同的builder，实际的类构造逻辑跟它的表现是分开的。 二、 模式下面是一般的UML类图 上图中的 product 表示你想要创建的实际的类，这个类被称为 Director （导演）所调用。 这个 Director 持有 builder 的一个实例，并调用它的 create() 方法，这个成员是 ConcreteBuilder 类的一个实例，这个 ConcreteBuilder 类实现了你想要的指定 product 的逻辑 这个抽象的逻辑是需要用来创建不同的 product 类型，这个 product 也可以是一个接口，每个 ConcreteBuilder 也可能返回一个不同的产品类型。 译者注：Director 表示具体创建 product 的类或者代码块；ConcreteBuilder 表示一个具体的 builder 类， 三、 一个例子使用这个例子主要描述不同车辆的构造，所有的代码包含在这个文件中this file 这个例子中的车辆就表示 product ，下面是具体的类：123456789101112131415161718192021#==============================================================================class Vehicle(object): def __init__(self, type_name): self.type = type_name self.wheels = None self.doors = None self.seats = None def view(self): print( "This vehicle is a " + self.type + " with; " + str(self.wheels) + " wheels, " + str(self.doors) + " doors, and " + str(self.seats) + " seats." ) 因此不同的车辆有不同的名字、轮胎的数量和座位数，这个 view() 方法将打印出车辆的具体信息。 车辆实例的构造将通过 ConcreteBuilder 类来完成的，这些类是来自 builder 接口（抽象类）,下面是 builder，即这个例子中的 VehicleBuilder 类代码：123456789101112131415161718#==============================================================================class VehicleBuilder(object): """ An abstract builder class, for concrete builders to be derived from. """ __metadata__ = abc.ABCMeta @abc.abstractmethod def make_wheels(self): raise @abc.abstractmethod def make_doors(self): raise @abc.abstractmethod def make_seats(self): raise 这里使用了python中的 ABC 模块译者注：ABC 模块是python中关于抽象类的一些定义 这个 builder 有三个方法用来设置车辆，这个例子中的 ConcreteBuilder 有两个： CarBuilder 和 BikeBuilder ，他们都是继承于 VehicleBuilder ,下面是这些类的实现：1234567891011121314151617181920212223242526272829#==============================================================================class CarBuilder(VehicleBuilder): def __init__(self): self.vehicle = Vehicle("Car ") def make_wheels(self): self.vehicle.wheels = 4 def make_doors(self): self.vehicle.doors = 3 def make_seats(self): self.vehicle.seats = 5#==============================================================================class BikeBuilder(VehicleBuilder): def __init__(self): self.vehicle = Vehicle("Bike") def make_wheels(self): self.vehicle.wheels = 2 def make_doors(self): self.vehicle.doors = 0 def make_seats(self): self.vehicle.seats = 2 这些类的逻辑就是对车辆的创建及属性的设置。为了使用这些，我们需要创建一个 Director 类，这个例子中就叫做 VehicleManufacturer12345678910111213141516171819#==============================================================================class VehicleManufacturer(object): """ The director class, this will keep a concrete builder. """ def __init__(self): self.builder = None def create(self): """ Creates and returns a Vehicle using self.builder Precondition: not self.builder is None """ assert not self.builder is None, "No defined builder" self.builder.make_wheels() self.builder.make_doors() self.builder.make_seats() return self.builder.vehicle 这个类有一个 create() 方法。作为你看到的，在注释中写明了：需要一个前提条件就是，需要给这个类中的 builder 属性显示的指定 ConcreteBuilder 。 下面是这个类的调用方式：1234567891011#==============================================================================if (__name__ == "__main__"): manufacturer = VehicleManufacturer() manufacturer.builder = CarBuilder() car = manufacturer.create() car.view() manufacturer.builder = BikeBuilder() bike = manufacturer.create() bike.view() 下面是结果输出：12This vehicle is a Car with; 4 wheels, 3 doors, and 5 seats.This vehicle is a Bike with; 2 wheels, 0 doors, and 2 seats. 下面是这个例子的UML类图： 这篇文章中的所有代码能在这里找到here 感谢你的阅读]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[redmine系统二次开发之search功能]]></title>
      <url>%2F2016%2F07%2F18%2Fredmine%E7%B3%BB%E7%BB%9F%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E4%B9%8Bsearch%E5%8A%9F%E8%83%BD%2F</url>
      <content type="text"><![CDATA[项目地址：https://github.com/tunsuy/redmine_select_search 一、 项目简介该项目主要是对redmine进行简单的二次开发，满足以下需求：在redmine的select选择框中，如果选项特别多，那么选择是非常考验眼力的，可能眼睛看花了都找不到那么就考虑对所有的select框增加搜索功能 二、 方案一1、 下载插件使用了chosen插件：https://harvesthq.github.io/chosen/ 2、 添加文件到项目目录中 将chosen.jquery.js文件添加到./apps/redmine/htdocs/public/javascripts/ 将chosen.css、chosen-sprite.png添加到 ./apps/redmine/htdocs/public/stylesheets/ 3、 引入js文件 编辑 ./apps/redmine/htdocs/app/helpers/application_helper.rb在下面方法处加入：1234567def javascript_heads tags = javascript_include_tag('jquery-1.11.1-ui-1.11.0-ujs-3.1.1', 'application', 'chosen.jquery') unless User.current.pref.warn_on_leaving_unsaved == '0' tags &lt;&lt; "\n".html_safe + javascript_tag("$(window).load(function()&#123; warnLeavingUnsaved('#&#123;escape_javascript l(:text_warn_on_leaving_unsaved)&#125;'); &#125;);") end tagsend 4、 引入css文件 编辑 ./apps/redmine/htdocs/app/views/layouts/base.html.erb在标签处加入：1&lt;%= stylesheet_link_tag 'chosen', :media =&gt; 'all' %&gt; 5、 实现 在./apps/redmine/htdocs/public/javascripts/application.js文件中添加实现代码 具体代码见项目地址 三、 方案二直接Hook前端代码实现 1、 加入拼音支持2、 实现 在./apps/redmine/htdocs/public/javascripts/application.js文件中添加实现代码 具体代码见项目地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[appium-ios自动化入门]]></title>
      <url>%2F2016%2F07%2F10%2Fappium-ios%E8%87%AA%E5%8A%A8%E5%8C%96%E5%85%A5%E9%97%A8%2F</url>
      <content type="text"><![CDATA[一、 简介为了更好的理解业内app自动化测试框架的原理机制，以便看是否有很好的办法在解决目前项目自动化测试存在的一些问题 这次先介绍appium的使用过程，后续有时间会看下其源码实现机制。 在mac下配置appium的自动化测试环境在这里就不说了，网上很多 因为查了下appium针对ios的自动化测试，网上的资料比较少，且说得不是很清楚，故这篇文章主要介绍怎样使用appium自动化测试自己的项目。 这些操作步骤均是自己亲自操作并实践通过的 这里已自己实现的一个简单的ios app来一步步介绍这篇文章先介绍在模拟器下运行的情况 二、 编译ios app命令行操作12$ cd /Users/xxx/Documents/lesFour/$ xcodebuild -sdk iphonesimulator 备注： 官网上的介绍中是这样写的：xcodebuild -sdk iphonesimulator6.0，表示编译成ios6版本的这里要说明的就是 如果你在这里指定了版本号，那么你就必须修改编译文件为对应的版本，不然运行不成功 这条命令会在项目目录下产生一个 build 文件夹，等下我们会用到里面的一些文件 关于 在命令行下编译 ios项目的知识 会在后续简单的介绍 三、 appium-ruby项目库切换到你喜欢的目录下，下载appium-ruby库123$ git clone https://github.com/appium/sample-code.git$ cd /Users/tunsuy/sample-code/sample-code/examples/ruby/ 因为mac自带ruby，所有这里直接更新项目依赖即可123$ gem install bundle$ bundle update 四、 测试项目1、 检查配置是否正确这里先运行一下官方的测试程序检查是否配置正确 在mac下启动一个终端，开启appium-server 12345$ appiuminfo: Welcome to Appium v1.3.5 (REV a124a15677e26b33db16e81c4b3b34d9c6b8cac9)info: Appium REST http interface listener started on 0.0.0.0:4723info: Console LogLevel: debug——启动成功 另启动一个终端 12$ cd /Users/xxx/sample-code/sample-code/examples/ruby/$ rspec simple_test.rb 注：这时可以看到appium-server所在的终端正在持续打出一系列日志，然后可以看到模拟器启动并测试成功 2、 自动化测试自己的项目 拷贝项目目录下之前编译产生的 build文件夹 到 /Users/xxx/sample-code/sample-code/apps/TestApp/ 目录下，覆盖掉已有的build文件夹（你也可以先备份再覆盖） 修改/Users/xxx/sample-code/sample-code/examples/ruby/目录下的simple_test.rb文件 1234 $ vi simple_test.rb#修改为： APP_PATH = '../../apps/TestApp/build/Release-iphonesimulator/lesThree.app' 为自己的路径 同时将module Calculator整个模块注释掉，也是自己的自动化代码，你也可以先不写，先看启动效果 启动测试 1$ rspec simple_test.rb 输出结果： 123No examples found.Finished in 0.00012 seconds0 examples, 0 failures 因为没有写测试代码，所有这里显示 0个案例，0个错误程序正常被启动起来了，如下图所示：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[深入详解Java迭代器]]></title>
      <url>%2F2016%2F07%2F05%2F%E6%B7%B1%E5%85%A5%E8%AF%A6%E8%A7%A3Java%E8%BF%AD%E4%BB%A3%E5%99%A8%2F</url>
      <content type="text"><![CDATA[java中的迭代器有三种 一、 Enumeration它是用于获取早期遗留集合（Vector，Hashtable）元素的接口。Enumeration 是JDK 1.0中的第一个迭代器，其余的包含在JDK 1.2中，具有更多的功能。Enumeration 也用于指定 SequenceInputStream 的输入流。我们可以通过在任何 Vector 对象上调用 elements() 方法来创建 Enumeration 对象1Enumeration e = v.elements(); Enumeration有两个方法：1234567// Tests if this enumeration contains more elementspublic boolean hasMoreElements();// Returns the next element of this enumeration// It throws NoSuchElementException// if no more element presentpublic Object nextElement(); 下面演示下该迭代器的使用123456789101112131415161718192021222324252627import java.util.Enumeration;import java.util.Vector;public class Test&#123; public static void main(String[] args) &#123; // Create a vector and print its contents Vector v = new Vector(); for (int i = 0; i &lt; 10; i++) v.addElement(i); System.out.println(v); // At beginning e(cursor) will point to // index just before the first element in v Enumeration e = v.elements(); // Checking the next element availability while (e.hasMoreElements()) &#123; // moving cursor to next element int i = (Integer)e.nextElement(); System.out.print(i + " "); &#125; &#125;&#125; 输出：12[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 0 1 2 3 4 5 6 7 8 9 Enumeration 的局限性： Enumeration 仅用于遗留类（Vector，Hashtable）, 因此，它不是一个通用的迭代器。 在遍历的时候不能执行删除操作。 只有向前方向迭代。 二、 IteratorIterator 它是一个通用的迭代器，因为我们可以将它应用到任何Collection对象。通过使用 Iterator，我们可以执行读取和删除操作。 当我们想遍历所有Collection框架中，实现了接口如Set，List，Queue，Deque以及Map接口的，所有实现类的元素时，都必须使用 Iterator。Iterator 是唯一可用于整个集合框架的游标。可以通过集合类的 iterator() 方法来创建：1Iterator itr = c.iterator(); Iterator 接口定义了三个方法：123456789101112// Returns true if the iteration has more elementspublic boolean hasNext();// Returns the next element in the iteration// It throws NoSuchElementException if no more// element presentpublic Object next();// Remove the next element in the iteration// This method can be called only once per call// to next()public void remove(); remove() 方法可以抛出两个异常： UnsupportedOperationException —— 此迭代器不支持删除操作 IllegalStateException —— 如果 next() 方法尚未被调用，或者在最后一次调用 next() 方法之后，已经调用了 remove() 方法 下面演示下这个迭代器的应用：1234567891011121314151617181920212223242526272829303132333435import java.util.ArrayList;import java.util.Iterator;public class Test&#123; public static void main(String[] args) &#123; ArrayList al = new ArrayList(); for (int i = 0; i &lt; 10; i++) al.add(i); System.out.println(al); // at beginning itr(cursor) will point to // index just before the first element in al Iterator itr = al.iterator(); // checking the next element availabilty while (itr.hasNext()) &#123; // moving cursor to next element int i = (Integer)itr.next(); // getting even elements one by one System.out.print(i + " "); // Removing odd elements if (i % 2 != 0) itr.remove(); &#125; System.out.println(); System.out.println(al); &#125;&#125; 输出：123[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]0 1 2 3 4 5 6 7 8 9[0, 2, 4, 6, 8] Iterator 的局限性： 在遍历的时候不支持替换和新增元素。 只有向前方向迭代。 三、 ListIterator它仅适用于列表集合实现的类，如 arraylist，linkedlist 等。它提供双向迭代。 当我们要遍历列表元素时，必须使用 ListIterator。它比 Iterator 有更多的功能（方法）。 ListIterator 对象可以通过调用列表接口中存在的 listIterator() 方法来创建。1ListIterator ltr = l.listIterator(); ListIterator 集成自 Iterator，所有具有 Iterator 所有的接口，并额外增加了6个接口123456789101112131415161718192021222324252627282930313233343536373839404142// Forward direction// Returns true if the iteration has more elementspublic boolean hasNext();// same as next() method of Iteratorpublic Object next();// Returns the next element index// or list size if the list iterator// is at the end of the listpublic int nextIndex();// Backward direction// Returns true if the iteration has more elements// while traversing backwardpublic boolean hasPrevious();// Returns the previous element in the iteration// and can throws NoSuchElementException// if no more element presentpublic Object previous();// Returns the previous element index// or -1 if the list iterator is at the// beginning of the listpublic int previousIndex();// Other Methods// same as remove() method of Iteratorpublic void remove();// Replaces the last element returned by// next() or previous() with the specified elementpublic void set(Object obj);// Inserts the specified element into the list at// position before the element that would be returned// by next(),public void add(Object obj); ListIterator 没有当前元素，它的光标位置总是位于通过调用 previous() 函数返回的元素和通过调用 next()返回的元素之间。 set() 可以抛出4个异常： UnsupportedOperationException —— 不支持该设置操作 ClassCastException —— 指定元素的类阻止将其添加到此列表中 IllegalArgumentException —— 指定元素的某些方面阻止将其添加到此列表中 IllegalStateException —— 没有调用 next() 或 previous()，或者在最后一次调用 next() 或 previous() 之后调用 remove() 或 add() add() 可以抛出3个异常： UnsupportedOperationException —— 不支持该设置操作 ClassCastException —— 指定元素的类阻止将其添加到此列表中 IllegalArgumentException —— 指定元素的某些方面阻止将其添加到此列表中 下面演示下这个迭代器的应用：12345678910111213141516171819202122232425262728293031323334353637383940import java.util.ArrayList;import java.util.ListIterator;public class Test&#123; public static void main(String[] args) &#123; ArrayList al = new ArrayList(); for (int i = 0; i &lt; 10; i++) al.add(i); System.out.println(al); // at beginning ltr(cursor) will point to // index just before the first element in al ListIterator ltr = al.listIterator(); // checking the next element availabilty while (ltr.hasNext()) &#123; // moving cursor to next element int i = (Integer)ltr.next(); // getting even elements one by one System.out.print(i + " "); // Changing even numbers to odd and // adding modified number again in // iterator if (i%2==0) &#123; i++; // Change to odd ltr.set(i); // set method to change value ltr.add(i); // to add &#125; &#125; System.out.println(); System.out.println(al); &#125;&#125; 输出：123[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 0 1 2 3 4 5 6 7 8 9[1, 1, 1, 3, 3, 3, 5, 5, 5, 7, 7, 7, 9, 9, 9] ListIterator 的局限性：它是最强大的迭代器，但它仅适用于List实现的类，因此它不是一个通用的迭代器。 四、 共同点1、请注意，最初任何迭代器引用将指向一个集合中第一个元素的索引之前的索引。2、我们不能创建 Enumeration，Iterator，ListIterator 的对象，因为它们是接口。我们使用像 elements()，iterator()，listIterator()这样的方法来创建对象。这些方法具有匿名内部类，它们扩展了相应的接口并返回此类对象。如下代码所示：12345678910111213141516171819202122import java.util.Enumeration;import java.util.Iterator;import java.util.ListIterator;import java.util.Vector;public class Test&#123; public static void main(String[] args) &#123; Vector v = new Vector(); // Create three iterators Enumeration e = v.elements(); Iterator itr = v.iterator(); ListIterator ltr = v.listIterator(); // Print class names of iterators System.out.println(e.getClass().getName()); System.out.println(itr.getClass().getName()); System.out.println(ltr.getClass().getName()); &#125;&#125; 输出：123java.util.Vector$1java.util.Vector$Itrjava.util.Vector$ListItr 引用类名称中的$符号是使用内部类的概念并创建这些类对象的证明。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[calabash-ios安装详解]]></title>
      <url>%2F2016%2F06%2F28%2Fcalabash-ios%E5%AE%89%E8%A3%85%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[一、 简介为了更好的理解业内app自动化测试框架的原理机制，以便看是否有很好的办法在解决目前项目自动化测试存在的一些问题 这次先介绍calabash的使用过程，后续有时间会看下其源码实现机制。 二、 工具安装这里以我自身的安装成功经历记录如下：1、启动终端 2、切换到被测项目路径下1cd /Users/XXX/Documents/lesFour/ 3、安装 calabash-cucumber gem包1gem install calabash-cucumber 4、生成 features文件夹1calabash-ios gen 三、 集成项目1、设置 xcode 项目I.复制项目target文件右键如下图红色部分 弹出提示框，选择Duplicate，弹出如窗口，选择如下图所示 复制出来如下图所示，名称为lesThree copy， 双击该项目，改名为lesThree-cal（根据你自己的项目名称来设置） II.修改复制项目的各处名称如下图点击，再下拉框中选择管理项目 弹出如下窗口，修改为如图所示名称（根据你自己的项目而定） 点击完成，进入如下图所示，修改为如图所示名称 III.导入calabash.framework框架将你项目目录下的calabash.framework拖到xcode项目中的Frameworks文件夹中，（如没有该文件夹，请创建），如图所示 再弹出的窗口中设置如图所示 IV.导入CFNetwork.framework如图所示导入 V.设置other linker flag如下图所示设置 四、 测试安装再模拟器中运行该cal项目，窗口控制台输出如下信息则表示配置成功122015-03-06 17:27:50.105 lesThree-cal[3279:55236] Started LPHTTP server on port 372652015-03-06 17:27:52.441 lesThree-cal[3279:55421] Bonjour Service Published: domain(local.) type(_http._tcp.) name(Calabash Server)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浅尝Python代码执行过程]]></title>
      <url>%2F2016%2F06%2F25%2F%E6%B5%85%E5%B0%9DPython%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[这篇文章将简单的从解释器和字节码的角度去看下python代码的执行过程 一、 简介在解释器接手之前，Python会执行其他3个步骤：词法分析，语法解析和编译。这三步合起来把源代码转换成code object,它包含着解释器可以理解的指令。而解释器的工作就是解释code object中的指令。 你可能很奇怪执行Python代码会有编译这一步。Python通常被称为解释型语言，就像Ruby，Perl一样，它们和编译型语言相对，比如C，Rust。然而，这里的术语并不是它看起来的那样精确。大多数解释型语言包括Python，确实会有编译这一步。而Python被称为解释型的原因是相对于编译型语言，它在编译这一步的工作相对较少（解释器做相对多的工作）。在这章后面你会看到，Python的编译器比C语言编译器需要更少的关于程序行为的信息。 二、 解释器Python解释器是一个虚拟机,模拟真实计算机的软件。这个虚拟机是栈机器，它用几个栈来完成操作（与之相对的是寄存器机器，它从特定的内存地址读写数据）。 Python解释器是一个字节码解释器：它的输入是一些命令集合称作字节码。当你写Python代码时，词法分析器，语法解析器和编译器生成code object让解释器去操作。每个code object都包含一个要被执行的指令集合 — 它就是字节码 — 另外还有一些解释器需要的信息。字节码是Python代码的一个中间层表示：它以一种解释器可以理解的方式来表示源代码。这和汇编语言作为C语言和机器语言的中间表示很类似。 三、 基本执行首先来看一个函数123456&gt;&gt;&gt; def add():... a = 1... b = 2... c = a + b... print(c)... Python在运行时会暴露一大批内部信息，并且我们可以通过REPL直接访问这些信息。对于函数对象add，add.__code__ 是与其关联的 code object，而 add.__code__.co_code 就是它的字节码。如下所示 字节码对象12&gt;&gt;&gt; add.__code__&lt;code object add at 0x7fe0a24518b0, file "&lt;stdin&gt;", line 1&gt; 字节码12&gt;&gt;&gt; add.__code__.co_code'd\x01\x00&#125;\x00\x00d\x02\x00&#125;\x01\x00|\x00\x00|\x01\x00\x17&#125;\x02\x00|\x02\x00GHd\x00\x00S' 光看这样一串字节码是无法理解是什么意思的，我们可以使用这样一个工具：Python标准库中的dis module。dis是一个字节码反汇编器。反汇编器以为机器而写的底层代码作为输入，比如汇编代码和字节码，然后以人类可读的方式输出 下面让我们来反编译一下刚才那个函数：12345678910111213141516171819&gt;&gt;&gt; import dis&gt;&gt;&gt;&gt;&gt;&gt; dis.dis(add) 2 0 LOAD_CONST 1 (1) 3 STORE_FAST 0 (a) 3 6 LOAD_CONST 2 (2) 9 STORE_FAST 1 (b) 4 12 LOAD_FAST 0 (a) 15 LOAD_FAST 1 (b) 18 BINARY_ADD 19 STORE_FAST 2 (c) 5 22 LOAD_FAST 2 (c) 25 PRINT_ITEM 26 PRINT_NEWLINE 27 LOAD_CONST 0 (None) 30 RETURN_VALUE 我们来解释下每一列代表什么意思： 第一列表示源代码所在行号； 第二列表示该指令的字节码索引； 第三列表示人类可理解的指令操作； 如果有第四列，表示该指令操作带参数； 如果有第五列，表示具体的参数是什么。从上面可以看出 a = 1 使用了两条指令来表示：LOAD_CONST 和 STORE_FAST ，分别表示加载常量 1 和存储变量 a 。 Python解释器中使用一个字节来表示指令，使用两个字节来表示一个指令的参数（为什么用两个字节表示指令的参数？如果Python使用一个字节，每个code object你只能有256个常量/名字，而用两个字节，就增加到了256的平方，65536个）。123456&gt;&gt;&gt; array.array("B",add.__code__.co_code)array('B', [100, 1, 0, 125, 0, 0, 100, 2, 0, 125, 1, 0, 124, 0, 0, 124, 1, 0, 23, 125, 2, 0, 124, 2, 0, 71, 72, 100, 0, 0, 83])&gt;&gt;&gt; dis.opname[100]'LOAD_CONST'&gt;&gt;&gt; dis.opname[125]'STORE_FAST' 所有前面6个字节表示了最开始的两条指令，也就是表示了 a = 1 这行代码。 四、 跳转到目前为止，我们的解释器只能一条接着一条的执行指令。这有个问题，我们经常会想多次执行某个指令，或者在特定的条件下略过它们。为了可以写循环和分支结构，解释器必须能够在指令中跳转。在某种程度上，Python在字节码中使用GOTO语句来处理循环和分支！先来定义一个函数1234567&gt;&gt;&gt; def cond():... flag = True... if flag == True:... print("true")... else:... print("false")... 然后反编译该函数字节码12345678910111213141516171819&gt;&gt;&gt; dis.dis(cond) 2 0 LOAD_GLOBAL 0 (True) 3 STORE_FAST 0 (flag) 3 6 LOAD_FAST 0 (flag) 9 LOAD_GLOBAL 0 (True) 12 COMPARE_OP 2 (==) 15 POP_JUMP_IF_FALSE 26 4 18 LOAD_CONST 1 ('true') 21 PRINT_ITEM 22 PRINT_NEWLINE 23 JUMP_FORWARD 5 (to 31) 6 &gt;&gt; 26 LOAD_CONST 2 ('false') 29 PRINT_ITEM 30 PRINT_NEWLINE &gt;&gt; 31 LOAD_CONST 0 (None) 34 RETURN_VALUE 第三行的条件表达式 if flag &lt; True 被编译成四条指令：LOAD_FAST, LOAD_GLOBAL, COMPARE_OP和 POP_JUMP_IF_FALSE。指令POP_JUMP_IF_FALSE完成if语句。这条指令把栈顶的值弹出，如果值为真，什么都不发生。如果值为假，解释器会跳转到另一条指令。 这条将被加载的指令称为跳转目标，它作为指令POP_JUMP的参数。这里，跳转目标是26，索引为26的指令是LOAD_CONST,对应源码的第6行。（dis用&gt;&gt;标记跳转目标。）因此解释器通过跳转指令选择性的执行指令。 五、 循环Python的循环也依赖于跳转。在下面的字节码中，while x &lt; 5这一行产生了和if x &lt; 10几乎一样的字节码。在这两种情况下，解释器都是先执行比较，然后执行POP_JUMP_IF_FALSE来控制下一条执行哪个指令。第四行的最后一条字节码JUMP_ABSOLUT(循环体结束的地方），让解释器返回到循环开始的第9条指令处。当 x &lt; 10变为假，POP_JUMP_IF_FALSE会让解释器跳到循环的终止处，第34条指令。 12345678910111213141516171819202122232425&gt;&gt;&gt; def loop():... x = 1... while x &lt; 5:... x = x + 1... return x...&gt;&gt;&gt; dis.dis(loop) 2 0 LOAD_CONST 1 (1) 3 STORE_FAST 0 (x) 3 6 SETUP_LOOP 26 (to 35) &gt;&gt; 9 LOAD_FAST 0 (x) 12 LOAD_CONST 2 (5) 15 COMPARE_OP 0 (&lt;) 18 POP_JUMP_IF_FALSE 34 4 21 LOAD_FAST 0 (x) 24 LOAD_CONST 1 (1) 27 BINARY_ADD 28 STORE_FAST 0 (x) 31 JUMP_ABSOLUTE 9 &gt;&gt; 34 POP_BLOCK 5 &gt;&gt; 35 LOAD_FAST 0 (x) 38 RETURN_VALUE 六、 栈帧到目前为止，我们已经知道了Python虚拟机是一个栈机器。它能顺序执行指令，在指令间跳转，压入或弹出栈值。但是这和我们心想的解释器还有一定距离。在前面的那个例子中，最后一条指令是RETURN_VALUE,它和return语句想对应。但是它返回到哪里去呢？ 为了回答这个问题，我们必须要增加一层复杂性：frame。一个frame是一些信息的集合和代码的执行上下文。frames在Python代码执行时动态的创建和销毁。每个frame对应函数的一次调用。— 所以每个frame只有一个code object与之关联，而一个code object可以很多frame。比如你有一个函数递归的调用自己10次，这时有11个frame。总的来说，Python程序的每个作用域有一个frame，比如，每个module，每个函数调用，每个类定义。 Frame存在于调用栈中，一个和我们之前讨论的完全不同的栈。（你最熟悉的栈就是调用栈，就是你经常看到的异常回溯，每个以”File ‘program.py’”开始的回溯对应一个frame。）解释器在执行字节码时操作的栈，我们叫它数据栈。其实还有第三个栈，叫做块栈，用于特定的控制流块，比如循环和异常处理。调用栈中的每个frame都有它自己的数据栈和块栈。 让我们用一个具体的例子来说明1234567891011&gt;&gt;&gt; def bar(y):... z = y + 3 ... return z...&gt;&gt;&gt; def foo():... a = 1... b = 2... return a + bar(b)...&gt;&gt;&gt; foo() 3 现在，解释器在bar函数的调用中。调用栈中有3个fram：一个对应于module层，一个对应函数foo,别一个对应函数bar。一旦bar返回，与它对应的frame就会从调用栈中弹出并丢弃。 字节码指令RETURN_VALUE告诉解释器在frame间传递一个值。首先，它把位于调用栈栈顶的frame中的数据栈的栈顶值弹出。然后把整个frame弹出丢弃。最后把这个值压到下一个frame的数据栈中。 那为什么一个frame必须要独立拥有一个数据栈呢？Python真的很少依赖于每个frame有一个数据栈这个特性。在Python中几乎所有的操作都会清空数据栈，所以所有的frame公用一个数据栈是没问题的。在上面的例子中，当bar执行完后，它的数据栈为空。即使foo公用这一个栈，它的值也不会受影响。然而，对应生成器，一个关键的特点是它能暂停一个frame的执行，返回到其他的frame，一段时间后它能返回到原来的frame，并以它离开时的同样的状态继续执行。 节选自 http://qingyunha.github.io/taotao/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS：https/ATS改造过程]]></title>
      <url>%2F2016%2F06%2F21%2Fios%EF%BC%9Ahttps-ATS%E6%94%B9%E9%80%A0%E8%BF%87%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[一、 背景苹果官方宣称今年底将全面强制启动https的支持1、不安全的HTTP链接将会遭到拦截 2、而且系统 Foundation 框架下的相关网络请求，将不再默认使用 HTTP等不安全的网络协议，而默认采用 TLS 1. 二、 服务端改造1、服务器需要改造的地方： ATS要求TLS1.2或者更高，TLS 是 SSL 新的别称。 通讯中的加密套件配置要求支持列出的正向保密。 数字证书必须使用sha256或者更高级的签名哈希算法，并且保证密钥是2048位及以上的RSA密钥或者256位及以上的ECC密钥。 2、服务器ATS在线检查： https://www.qcloud.com/product/ssl#userDefined10 三、 官方建议1、苹果官方是推荐使用NSURLSession去做HTTP请求的 2、虽然说NSURLConnection同样支持ATS方面的特性，两者的默认行为上有些不一样所以应该尽早切换到NSURLSession上，避免产生一些不必要错误。 四、 项目改造1、要么将info.plist中的allow全部改成NO 2、要么在提交审批的时候向苹果说明 五、 测试1、抓包查看所有请求情况ps：推荐Charles——mac下很好用的一款抓包软件 2、在项目im中浏览https网址和http网址https://www.baidu.com——SSL错误原因： 百度自身服务器ssl协议没有指定支持TSLv1.0解决：(参考) 服务器自身配置下 在Info.plist里配置，指定支持TSLv1.0https://github.com/sinaweibosdk/weibo_ios_sdk 六、 参考链接http://www.liuchungui.com/blog/2015/10/11/ios9zhi-gua-pei-ats/https://my.oschina.net/vimfung/blog/494687?_t_t_t=0.1896578531749944https://onevcat.com/2016/06/ios-10-ats/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[calabash-android原理分析]]></title>
      <url>%2F2016%2F06%2F20%2Fcalabash-android%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[在前面已经简单的介绍了calabash-ios的原理，这里将继续分析calabash-Android端的原理 一、 原理解析calabash-android架构其实与IOS是相同的 1、内部使用核心为cucumber的calabash的脚本在运行测试的时候会在虚拟机/真机上预装一个web服务器，这个web服务器就是解释calabash的脚本， 2、因为calabash-Android是基于robotium框架的，所以在机器上预装的web-server会将下发下来的calabash脚本解释为robotium的脚本，然后向测试app发送robotium的脚本， 3、因为robotium框架就是封装的google测试框架instumentation，所以app拿到robotium脚本后，将其解释为instumentation命令向被测试的app发送这些命令，被测试的app执行这些命令，然后将结果返回。 二、 系统架构图calabash-Android整个框架采用 C/S 的运行模式，系统架构如下图所示： 三、 框架图解释1、Runner 负责接受用户指令，并对其进行数据校验、指令转换等操作，之后将其交由客户端处理（这里的客户端是指运行在pc上的用户自己编写的代码）， 2、instrumentation test server就是预装在设备上的web-server，客户端在接收到指令之后，将指令发送给它，请求其执行对应操作， 3、web-server在接收到指令之后，解释该命令并与app进行交互， 4、所有执行结果最终会被收集到 Results 中。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[docker自定义daemon选项]]></title>
      <url>%2F2016%2F06%2F15%2Fdocker%E8%87%AA%E5%AE%9A%E4%B9%89daemon%E9%80%89%E9%A1%B9%2F</url>
      <content type="text"><![CDATA[一、 前提可以定义的选项为如下列出来的1docker-current daemon --help 二、 方案一1、 分别定义各环境文件12eg：/etc/sysconfig/docker-storage/etc/sysconfig/docker-network 该文件中可以自定义环境变量 2、 引入环境文件在/usr/lib/systemd/system/docker.service文件中引入环境文件12eg：EnvironmentFile=-/etc/sysconfig/docker-storageEnvironmentFile=-/etc/sysconfig/docker-network 并使用其环境变量123ExecStart=/usr/bin/docker-current daemon \ $DOCKER_STORAGE_OPTIONS \ $DOCKER_NETWORK_OPTIONS \ 备注：也可以将所有的自定义选项定义在一个文件中 例：将官方镜像仓库替换为阿里云镜像仓库 前提：注册阿里云用户，此时才会获取到一个私有的镜像仓库地址https://cr.console.aliyun.com/ 在/etc/sysconfig/docker中的option变量中加上如下选项 1--registry-mirror=https://u6nqa61i.mirror.aliyuncs.com 重启docker： 1systemctl restart docker 三、 方案二直接在/usr/lib/systemd/system/docker.service文件中加入选项123eg：ExecStart=/usr/bin/docker-current daemon \ --exec-opt native.cgroupdriver=systemd \ --insecure-registry docker.ts.com:5000 四、 方案三使用daemon.json文件官方文档：https://docs.docker.com/engine/reference/commandline/dockerd/#/linux-configuration-file路径：/etc/docker/daemon.json备注：使用此方案不要与其他方案相混合使用，否则docker启动的时候会报错]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[详解JVM原理及其内部构件]]></title>
      <url>%2F2016%2F06%2F11%2F%E8%AF%A6%E8%A7%A3JVM%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%86%85%E9%83%A8%E6%9E%84%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[节选自：http://www.cubrid.org/blog/dev-platform/understanding-jvm-internals/ 一、 JVM特性1、 简介1、虚拟机栈：最流行的计算机架构比如intel x86架构和arm架构都是基于寄存器运行的，然而，jvm是基于栈运行的 2、符号引用：所有的类型（类和接口）除了原始类型（即基本类型）都是被符号引用所引用的，代替显示的通过内存地址引用译者注：符号引用即变量 3、GC垃圾回收：一个类实例通过用户代码显示的创建，而通过GC自动回收，不用手动干预。 4、基本数据类型平台独立：传统的编程语言比如c++根据不同的平台有不同的int类型内存大小，而jvm显示的定义了基本数据类型的内存大小，跟平台是无关的。 5、网络字节序：java类文件使用的时候网络字节序。为的是保持平台无关性：Intel x86架构使用的是小端字节序，而RISC 系列架构使用的大端字节序，所有一个固定的字节序必须被保持。jvm使用的网络字节序是被用于网络传输的。网络字节序是大端字节序。 虽然java 是sun公司开发的，但是任何的供应商只要遵循jvm规范，都可以开发和提供jvm虚拟机。正因为这个原因，有各种各样的jvm，包括oracle Hotspot jvm 和IBM JVM。Google的安卓系统上的Dalvik VM也是JVM中的一种，但是它没有遵循JVM规范。不同于java VMs的虚拟机栈，Dalvik VM是基于寄存器架构的。Dalvik VM会将java字节码转换成基于寄存器的指令集。 2、 Java字节码为了实现平台无关性，JVM使用java字节码，java字节码是处于java（用户语言）和机器语言的一种中间语言，java字节码是发布java代码最小的单元。在解释java字节码之前，让我们先来看看它，这个列子是发生在开发进程中的真实列子的总结。 二、 JVM结构1、 执行流程java代码是按照下图所示的流程执行的 类加载器将javac编译的java字节码加载进运行时数据区；而执行机则执行java字节码 2、 类加载器java提供了动态加载特性；类加载器是在运行时而不是编译时，将加载和链接它所引用到的类。JVM的类加载器执行这个动态加载。类加载器具有如下这些特性： 1、分层结构：类加载器是以父子关系组成的一个分层结构，Bootstrap 加载器是所有加载器的父类。 2、委托模式：基于这个分层结构，类加载器之间是委托加载的。当一个类加载的时候，这个父类加载器将被检查来确定这个类是否在这个父类加载器中，如果父类加载器已经有了这个类，则直接使用，否则，这个类加载器将加载这个类。 3、可见性：一个子类加载器可以找到父类加载器中的类，但是，一个父子类加载器不能找到子类加载器中的类。 4、不能卸载：一个类加载器可以加载类但是不能卸载类，代替卸载的是，这个类加载器可以被删除，然后重新创建一个类加载器。 每一个类加载器有自己的名字空间用来存储加载的类。当一个类加载器加载一个类时，它根据FQCN （全类名匹配）在存储在名字空间中的类来搜索类，并且检查其是否已经被加载过了。如果一个类有相同的名字但是在不同的名字空间，类加载器会认为它是一个不同的类。如图 3、 运行时数据区 运行时数据区是一个内存区域，是在JVM程序在操作系统上运行时分配的。这个运行时区分为6个区域： 线程私有：PC寄存器（程序计数器），JVM栈，本地方法栈 线程共享：堆，方法区，运行时常量池 1、PC寄存器：又叫程序计数器，存在于每一个线程中，在线程开始的时候被创建，它存储正在被执行的JVM指令地址 2、JVM栈：存在于每一个线程中，在线程开始的时候被创建。它是一个个结构体（栈帧）的栈空间。JVM将栈帧入栈和出栈 栈帧：一个栈帧当一个方法在JVM中执行的时候被创建，然后被添加进这个线程的JVM栈中。当这个方法结束的时候，这个栈帧就被移除了。每个栈帧包括本地变量组的引用，操作栈和该方法所属的类的运行时常量池。本地变量组和操作栈的大小在编译时就被确定了，因此，一个栈帧的大小是根据方法来确定的。 本地变量组：它的索引从0开始，0表示这个方法所属的类实例的引用，所以方法参数是从索引1开始保存在这个本地变量组中的。最后才是依次保存该方法的本地变量。 操作栈：表示一个方法的实际工作空间。每个方法在操作栈和本地变量组之间交换数据。对其他方法的调用结果进行出栈和入栈。操作栈所需要的空间在编译时就被确定了。 3、本地方法栈：表示其他语言（非java）写的本地代码栈。换句话说，它是一个被JNI调用的C/C++代码执行时使用的栈空间。 4、方法区：这个方法区被所有的线程共享。当JVM开始的时候被创建。它存储运行时常量池，域和方法信息，静态变量和被JVM读取的每个类和接口的方法字节码。方法区根据不同的JVM供应商而被实现为了不同的格式。Oracle Hotspot JVM 叫它永生代。对于每个JVM供应商，这个方法区对于GC是可选的。 5、运行时常量池：这个区域包含在方法区中，它是JVM操作中的一个很核心的角色。因此，JVM规范分开描述了它的重要性。包含了每个类和接口的常量，方法和域的引用。简单的说，当一个方法和域被引用的时候，JVM搜索这个方法和域在运行时常量池中的实际的地址 6、堆：存储实例和对象的一个空间。是GC的一个操作目标。这个空间在讨论JVM性能的时候被经常提到。这JVM供应商能确定这个堆怎么配置或者不被回收。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[基于docker的moa服务]]></title>
      <url>%2F2016%2F06%2F02%2F%E5%9F%BA%E4%BA%8Edocker%E7%9A%84moa%E6%9C%8D%E5%8A%A1%2F</url>
      <content type="text"><![CDATA[一、 简介该文章主要讲解将公司的server服务docker化的具体过程，从中可以看到很多docker相关知识的使用以及网络配置等操作文中还设计到自己实现的关于docker自动化配置的两个脚本，供大家学习参考 二、 docker化步骤1、 将初始安装包拷贝到容器主机上 2、在主机上拉取一个centos6.7的docker镜像ps：因为官方的docker镜像都是轻量级的，所有很多linux下的命令都没有 方法一 就是要么自己将所有的命令工具都安装了 方法二 找一个别人建好的docker镜像 3、将主机上的安装包共享给容器，并交互式形式启动1docker run -t -i --name moa_centos7 -v /home/tunsuy/toContainer:/home/tunsuy/fromHost centos:centos7 /bin/bash 4、因为没有空白机的公有云安装包，所以这里以私有云空白安装包来安装ps：./install.sh -m test -d public_clound——参考./install.sh脚本实现 5、安装过程中可能会遇到一些问题 提示没有xx命令——一律yum install xx即可 提示连接不上mongodb——中断安装（其实moa依赖的一些软件环境已经安装成功了）——参考其他虚拟机公有云的mongodb安装情况，调整该docker容器中的mongodb并成功启动 6、单独安装公有云升级包（该包中需要包含dbserver服务包） 7、安装包成功之后，检查各项服务是否成功（包括web、流程、商店等） 可能会发现mysql安装异常——手动安装：进入私有云空白安装包中的init目录下，运行./install.sh————安装过程中可能会报错，缺少某些依赖————依次yum install安装（有的可能需要自己下载安装） 8、所有的服务都检查无误时，制作镜像并上传 搭建私有仓库（按照官方文档做就可以了，这里不详细写） 将容器制作为镜像 1docker commit --author "ts" --message "更正moaserver初始化包环境" 容器名 docker.ts.com:5000/moaserver_env:init 上传镜像到私有仓库 1docker push docker.ts.com:5000/moaserver_env:init ps：配置私有仓库http访问编辑文件：vim /etc/sysconfig/docker添加以下内容1OPTIONS='--selinux-enabled --insecure-registry=docker.ts.com:5000' 或者编辑文件：vim /usr/lib/systemd/system/docker.service添加以下内容123456789 ExecStart=/usr/bin/docker-current daemon \ --exec-opt native.cgroupdriver=systemd \ $OPTIONS \ $DOCKER_STORAGE_OPTIONS \ $DOCKER_NETWORK_OPTIONS \ $ADD_REGISTRY \ $BLOCK_REGISTRY \ $INSECURE_REGISTRY \--insecure-registry docker.ts.com:5000 注：centos7的防火墙使用的是firewalld，因为之前对iptables比较熟， 所以可以关掉firewalld，安装iptables服务123systemctl stop firewalldsystemctl mask firewalldyum install iptables-services 三、 服务使用1、 从私有仓库拉取该镜像并使用1docker run -t -i --name=moaserver_env --net="none" -v /home/tunsuy/toContainer:/home/tunsuy/fromHost docker.ts.com:5000/moaserver_env:init /bin/bash ps：这里采用none的网络方式，是因为想自己配置所有网络 2、 配置容器IP这里使用我写的一个工具脚本：1sh bind_addr.sh moaserver_env 172.17.0.2 ps：需要在主机上执行，而不是在容器中脚本地址：https://github.com/tunsuy/TSTools/tree/master/ShellTools/docker相关 3、 配置环境变量1source /etc/profile ps：由于之前在镜像中配置的环境变量，在容器中不能自动生效（原因不明） 4、 启动mongo和mysql123/etc/init.d/mongod start/etc/init.d/mysqlaccd stop/etc/init.d/mysqld start 5、 更新hosts文件12345#将模板文件写入hosts：cat /home/tunsuy/fromHost/host_templet &gt;&gt; /etc/hosts#将hosts中的IP改成容器ipmdbg -p 23808 -o changeip oldip=172.17.0.1,newip=172.17.0.2 ps：容器的/etc/hosts、/etc/resolv.conf文件是挂载在宿主机中的 6、 启动moa服务1/etc/init.d/moa start 7、端口映射想要外部访问该docker，还需要进行主机和容器的端口映射有两种方式： 在新建一个容器的时候就指定（一般都是这样） 在已生成的容器中动态配置：主要还是基于iptables来设置（因为docker的原理实际上也是这样的）因为之前我们在创建容器的时候没有指定，所以这里以第二种来配置123iptables -A DOCKER ! -i docker0 -o docker0 -p tcp --dport 443 -d 172.17.0.1 -j ACCEPTiptables -t nat -A POSTROUTING -p tcp --dport 443 -s 172.17.0.1 -d 172.17.0.1 -j MASQUERADEiptables -t nat -A DOCKER ! -i dokcer0 -p tcp --dport 443 -j DNAT --to-destination 172.17.0.1:443 ps：为了方便，写了一个工具脚本1sh docker_expose.sh moaserver_env 172.17.0.2 add 4432:443 脚本地址： https://github.com/tunsuy/TSTools/tree/master/ShellTools/docker相关 注：查看iptables情况12iptables -nvxL --line-numbersiptables -t nat -nvxL --line-numbers 四、 不足之处因为所有的容器都是基于宿主机的，最多通过修改时区来设置，也就只能偏移24小时网上有一种方案，不知可行不：https://github.com/wolfcw/libfaketime/ 五、 参考链接https://yeasy.gitbooks.io/docker_practice/content/cases/supervisor.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[谈谈linux下Bash中的函数返回值]]></title>
      <url>%2F2016%2F05%2F25%2F%E8%B0%88%E8%B0%88linux%E4%B8%8BBash%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%2F</url>
      <content type="text"><![CDATA[Bash函数与大多数编程语言中的函数不同，不允许你向调用者返回值。当bash函数结束时，返回值为其状态：成功为零，失败为非零。要返回值，可以使用结果设置一个全局变量，或者使用命令替换，也可以传入一个变量的名称作为结果变量。下面的例子描述了这些不同的机制。 一、 全局变量法从bash函数返回值的最简单的方法是将全局变量设置为结果。由于bash中的所有变量默认为全局变量（不管是在哪个块中定义的）示例如下： 1234567891011121314151617181920lockdir="somedir"retval=-1testlock()&#123; if mkdir "$lockdir" then # directory did not exist, but was created successfully echo &gt;&amp;2 "successfully acquired lock: $lockdir" retval=0 else echo &gt;&amp;2 "cannot acquire lock, giving up on $lockdir" retval=1 fi&#125;testlockif [ "$retval" == 0 ]then echo "directory not created"else echo "directory already created"fi 缺点：我们都知道，使用全局变量，特别是在大型程序中，可能导致难以发现错误 二、 echo法更好的方法是在函数中使用局部变量。那么问题就是如何把结果传给调用者。一种机制是使用命令替换：123456789101112131415161718192021lockdir="somedir"testlock()&#123; retval="" if mkdir "$lockdir" then # directory did not exist, but was created successfully echo &gt;&amp;2 "successfully acquired lock: $lockdir" retval="true" else echo &gt;&amp;2 "cannot acquire lock, giving up on $lockdir" retval="false" fi echo "$retval"&#125;retval=$( testlock ) #也可以 `testlock`if [ "$retval" == "true" ]then echo "directory not created"else echo "directory already created"fi 三、 函数参数法返回值的另一种方法是编写函数，以便它接受变量名作为其命令行的一部分，然后将该变量设置为该函数的结果123456789function myfunc()&#123; local __resultvar=$1 local myresult='some value' eval $__resultvar="'$myresult'"&#125;myfunc resultecho $result 这里我们必须使用eval来实际设置。 eval语句基本上告诉bash将该行解释为两次，上面的第一个解释会导致字符串result =’some value’，然后再解释一次，最后设置调用者的变量。 以下两种方式等效：方式二12345678function myfunc()&#123; local __resultvar=$1 eval $__resultvar="some value"&#125;myfunc resultecho $result 方式三1234567function myfunc()&#123; eval $1="'some value'"&#125;myfunc resultecho $result 四、 返回状态法虽然bash有一个返回语句return，但你可以指定的唯一的事情是函数的状态，它是一个 数值，如在exit语句中指定的值。 状态值存储在$？变量中。如果函数不包含 return 语句，则其状态将基于函数中执行的最后一条语句的状态设置。123456789101112131415161718192021lockdir="somedir"testlock()&#123; if mkdir "$lockdir" then # directory did not exist, but was created successfully echo &gt;&amp;2 "successfully acquired lock: $lockdir" retval=0 else echo &gt;&amp;2 "cannot acquire lock, giving up on $lockdir" retval=1 fi return "$retval"&#125;testlockretval=$?if [ "$retval" == 0 ]then echo "directory not created"else echo "directory already created"fi]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS下使用UI-Testing进行发包前Checklist检查]]></title>
      <url>%2F2016%2F05%2F19%2FiOS%E4%B8%8B%E4%BD%BF%E7%94%A8XCTest%E8%BF%9B%E8%A1%8C%E5%8F%91%E5%8C%85%E5%89%8DChecklist%E6%A3%80%E6%9F%A5%2F</url>
      <content type="text"><![CDATA[一、 UI Testing简介1、UI Testing 是基于 XCTest 测试框架的。XCTest 作为 OCUnit 的替代者，目前是 iOS 单元测试框架不二之选，很多其他测试框架也基于 XCTest 封装。XCTest 有如下特点： 测试用例需要继承 XCTestCase 有类似 Junit 的 setup 或者 teardown方法 还算不错的 Assertions 和 Xcode 深度集成 可以使用 Xcode server 的持续集成。支持 Swift 和 Objective-C 2、那 UI Testing 在 XCTest 的基础上实际上是扩展了几个类，协议所以本质上 UI Testing 还是 XCTest，所以写用例的时候，还是需要遵从 XCTest 的规则 3、UI Testing 需要依靠 Accessibility 来定位元素。UI Testing 可以通过你的应用提供的 Accessibility 功能来与你的应用连接，这样就解决了设备大小不一的问题。如果你重新调整了 UI 中的某些元素，你也不用重写整套测试。当然实现 Accessibility 的本质不是为了使用 UI Testing，而是为了能帮助行动不便的用户更好地使用你的应用。 二、 具体实践Xcode 7中创建新工程时，可以选择是否要包含UI测试——这里就不演示了 下面说说在已有工程的时候，怎么进行UI Testing1、再项目工程中增加一个target 如图中1所示点击添加UI Testing Bundle添加之后如图中2、3所示。 2、编写测试类或者测试方法在图中3所示中的.m文件中添加测试方法，当然实际项目中，肯定是根据各自的模块自己新建一系列的类及方法（注：测试类及其测试方法必须按照XCTest的命令规则及要求来） 3、运行测试用例可以直接在导航栏中点击test运行整个UI用例 也可以如图中所示 点击用例右边的勾运行单个用例 UI testing 也具有录制功能 如图 点击图中所示 它将重新启动app ，然后你的每一步操作都将在你鼠标所在处自动生成OC代码（注：由于UI testing 刚出来 所以录制出来的代码可能不是很规范 需要手动改一下。不过作为官方推出来的东西，以后肯定会变得更简单强大） 三、 使用建议UI testing到底适用于什么地方呢 个人认为用来做一些简单的发包前check list比较合适 比如 我们项目在迭代发包钱都需要测试或者开发自己跑一遍check list ，作为程序员，这些简单重复的操作交给程序来运行就好了。因为UI testing 可以使用OC语言来写 所以对于开发来说 这将是非常简单的。 四、 最后具体的UI testing API 可以参看官方文档 不多比较简单]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java：ArrayList和LinkedList的对比]]></title>
      <url>%2F2016%2F05%2F13%2FJava%EF%BC%9AArrayList%E5%92%8CLinkedList%E7%9A%84%E5%AF%B9%E6%AF%94%2F</url>
      <content type="text"><![CDATA[ArrayList 和 LinkedList 都实现了 list 接口，它们的方法和返回结果都几乎是一样的。然而它们还是有一些差异，不同的场合它们各自有不同的优势。 一、 不同点1、 Search搜索ArrayList 的搜索操作比 LinkedList 快很多。get(int index) 在 ArrayList 的时间复杂度为 O(1)，而在 LinkedList 中是 O(n). 原因：ArrayList 是基于索引的元素，因为它内部是使用的array数据结构。而 LinkedList 是基于双向链表的实现，需要遍历元素来找到需要的元素。 2、 Deletion删除LinkedList 的删除操作的时间复杂度为 O(1)，而 ArrayList 在最坏的情况下(删除首元素)为 O(n)，最好的情况下(删除最后一个元素)为 O(1)。 结论：LinkedList 元素删除操作是快于 ArrayList 的。 原因：LinkedList 每个元素都持有两个引用指向相邻的元素。因此删除元素只需要改变所删除元素相邻节点的引用即可。然而 ArrayList 需要移动所有的元素来填充被删除元素的位置。 3、 插入性能LinkedList 的插入操作的时间复杂度为 O(1)，而 ArrayList 的时间复杂度为 O(n)，原因跟删除操作一样。 4、 内存占用ArrayList 持有索引和元素数据，而 LinkedList 持有元素数据和指向两个相邻节点的引用。因此 LinkedList 内存占用相对来说更多。 二、 相同点1、两个都实现了 List 接口2、两个都保持元素插入顺序，意味着元素显示顺序跟插入的顺序是一致的。3、两个都是非同步的(线程不安全的)，能够使用 Collections.synchronizedList) 进行同步。4、两个返回的 iterator 和 listIterator 都是 fail-fast (如果列表在迭代器创建之后的任何时间被修改，除非通过迭代器自己的remove或add方法，否则迭代器将抛出 ConcurrentModificationException) 三、 使用场景1、如上所述，与 ArrayList(O(n)) 相比，插入和移除操作在 LinkedList 中有更好的性能 (O(1))。因此，如果需要在应用程序中频繁添加和删除，那么 LinkedList 是一个最好的选择。2、搜索(get方法)操作在 Arraylist(O(1)) 中很快，但在 LinkedList(O(n)) 中更慢，所以如果有较少的添加和删除操作和更多的搜索操作要求，ArrayList 将是你最好的选择。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS：UIWebView与WKWebView注意事项]]></title>
      <url>%2F2016%2F04%2F28%2Fios%EF%BC%9AUIWebView%E4%B8%8EWKWebView%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
      <content type="text"><![CDATA[一、 基本介绍1、UIWebView 使用的 JavaScriptCore 框架，交互时为 JavaScript 运行的上下文环境 JSContext 注入对象 Bridge； 2、WKWebView 使用的 WebKit 框架，交互时为 webkit.messageHandlers 注入对象 二、 测试注意事项1、加载速度 2、占用内存 3、缓存问题：H5页面更新了，app端显示还是老的，不同的ios系统处理方式不一样 4、cookie问题页面很多，不断切换浏览，cookie失效等 5、跨域问题webkit框架不允许跨域，比如从一个http页面对https发起请求 6、request拦截问题有可能之前用的好好的hybrid框架，换了wkwebview之后，有些就不起作用了 7、本地html文件加载不同的ios系统不一样 8、手势操作 三、 参考链接http://mp.weixin.qq.com/s/18xXQWboHcjybd_VtcTmUg##]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[selenium远程启动浏览器]]></title>
      <url>%2F2016%2F04%2F14%2Fselenium%E8%BF%9C%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%B5%8F%E8%A7%88%E5%99%A8%2F</url>
      <content type="text"><![CDATA[一、 方案一通过selenium-server 1、 相关下载 下载server：http://seleniumhq.org/download/ 下载chrome-driver：https://sites.google.com/a/chromium.org/chromedriver/downloads 2、 开启selenium-server在浏览器主机的终端上执行命令：1java -Dwebdriver.chrome.driver="D:\chromedriver.exe" -jar selenium-server.jar 3、 编写client脚本测试接下来就可以在其他主机上编写测试脚本并执行了：以python为例 下载基本python的selenium库： 1pip install selenium 编写示例脚本如下： 12345678from selenium import webdriverfrom selenium.webdriver.common.desired_capabilities import DesiredCapabilitiesdriver = webdriver.Remote( command_executor='http://200.200.105.63:4444/wd/hub', desired_capabilities=webdriver.DesiredCapabilities.CHROME)driver.get('https://200.200.169.165'); 二、 方案二直接使用driver 1、 相关下载按照1中的下载好相应的浏览器驱动 2、 开启chromedriver在浏览器主机的终端上执行命令：1chromedriver.exe --whitelisted-ips="200.200.169.162" 3、 编写client脚本测试编写示例脚本如下：1234567from selenium import webdriverdriver = webdriver.Remote( command_executor='http://200.200.105.63:9515', desired_capabilities=DesiredCapabilities.CHROME)driver.get('https://200.200.169.165');]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[redmine迁移：从windows下迁移到linux]]></title>
      <url>%2F2015%2F10%2F27%2Fredmine%E8%BF%81%E7%A7%BB%EF%BC%9A%E4%BB%8Ewindows%E4%B8%8B%E8%BF%81%E7%A7%BB%E5%88%B0linux%2F</url>
      <content type="text"><![CDATA[一、 迁移步骤1、在linux下将redmine安装好 2、从原来的服务器上（windows）导出数据库文件（sql文件） 3、将现在的服务器（linux）上的redmine数据库清空注：是清空，不能删除，因为删除会导致之后访问不了，具体原因可能是兼容问题 4、将2步中导出来的sql文件导入3步中清空的redmine数据库中注：可能返回结果会提示说有错误，记下出错的表 5、将出错的表重新删除再导入注：记住是删除，不是清空到目前为止数据库文件已经全部导入成功了 6、附件的导入——将原来的服务器上的redmine中files文件拷贝到现在的服务器上的相同目录下 至此全部迁移数据已完成 二、 问题及解决方法：1、 redmine的rtx提醒链接错误收到的连接还是原来服务器的链接排查： 查看邮件配置文件是否正确——正确 通过rtx提醒的脚本调试发现redmine传递给rtx的提醒内容就是提问题时填写的内容（也就是数据库中的内容） 于是进入数据库中相应表（setting）查看，问题真是出在这里：这个表有个字段是设置hostname的，填写的还是以前的url（因为是导入以前的数据嘛） 解决：将该字段改为正确的访问ip即可 2、 redmine上的时间显示不对排查：查看服务器时间——问题确实出在这里解决：将服务器时间设为当前时间 3、 无法上传附件排查： 上传一个附件，没有返回错误，但是就是显示不出来 查看数据库，确实没有插入进去 既然能查看以前的附件，为什么迁移过来后就上传不了呢？ 联想：附件目录（files）是不是只有可读权限啊 解决： 将files目录设置为可读写权限（chmod 777 ./files/*） 重启服务，再次上传，成功]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[calabash-ios原理分析]]></title>
      <url>%2F2015%2F06%2F12%2Fcalabash-ios%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[calabash同时支持ios和Android平台，这里只介绍ios平台。 一、 系统架构图calabash-ios整个框架采用 C/S 的运行模式，系统架构如下图所示： 二、 框架分析接上图 1、其中，Runner 负责接受用户指令，并对其进行数据校验、指令转换等操作 2、之后将其交给客户端处理（这里的客户端是指运行pc上的代码） 3、客户端将指令发送给对应服务器http server（这里的服务器就是编译进app中的calabash.framework），请求其执行对应操作 4、client-server两者之间通过 JSON 格式的数据进行交互 5、所有执行结果最终会被收集到 Results 中。 6、Calabash-iOS 服务器是基于Frank构建的，Frank也是一种基于cucumber的自动化测试框架。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[利用leakcanary检测android内存泄露]]></title>
      <url>%2F2015%2F06%2F10%2F%E5%88%A9%E7%94%A8leakcanay%E6%A3%80%E6%B5%8Bandroid%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%2F</url>
      <content type="text"><![CDATA[leakcanary的知识就不在这里普及了，随便Google下就知道 一、 项目集成直接说在项目中怎么操作，如下：1、在 build.gradle 中加入引用，不同的编译使用不同的引用：1234dependencies &#123; debugCompile 'com.squareup.leakcanary:leakcanary-android:1.3' releaseCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.3'&#125; 2、在你的项目的 Application 中：123456public class ExampleApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); LeakCanary.install(this); //加上这一句 &#125;&#125; 这样， 重新打包安装之后 ，在操作测试该APP的过程中，如果检测到某个 activity 有内存泄露，LeakCanary 就是自动地显示一个通知。 二、 具体实践具体以我们口袋助理来介绍下： 1、在build.gradle 中加入引用 2、在MoaApplication.java中的onCreate方法中加入1LeakCanary.install(this); 3、故意造一个内存泄露的地方以创建工作汇报为例：将CreateWorkReportActivity.java中的EditText变量改为静态的(static) 4、编译打包查看效果 这个时候安装应用到手机，会自动安装一个Leaks应用注：有的手机需要重启下才能看到Leaks应用，比如我用的华为手机就是这样 5、检查是否真的如我们预期的一样：在创建工作汇报的时候存在内存泄露创建一个工作汇报，回到汇报列表，此时我们会发现收到了一个Leaks的通知如图： 点击该通知，进入Leaks，可以查看到详细的该内存泄露的调用信息，从而定位到该内存泄露如图：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[基于ruby-trello的trello系统数据写入工具]]></title>
      <url>%2F2015%2F05%2F15%2F%E5%9F%BA%E4%BA%8Eruby-trello%E7%9A%84trello%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5%E5%B7%A5%E5%85%B7%2F</url>
      <content type="text"><![CDATA[Demo详见我的github：https://github.com/tunsuy/TSTools/blob/master/RubyTools/trello数据上传.rb 一、 背景目前moa测试这边经常会用excel文档写一些场景测试案例，同时，随着对开发自测能力的加强，还会在trello系统上列一份同样的研发自测案例点，为了减少一些不必要的重复工作，编写了一个工具来将excel文档中的内容根据不同的测试类和测试点自动写入trello系统 二、 思路主要用到了基于ruby的trello API 1、首先要先获取trello的key值和相关权限的token值（不同的权限，token值时不一样的） 2、通过获取到的key值和token值进行trello认证 3、然后调用相关的ruby-trello API，进行相应的读写操作 4、这里我还对不同的测试类及其对应的测试点进行了分类写入，这样方便研发根据自己负责的分模块进行自测]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[利用drozer进行Android渗透测试]]></title>
      <url>%2F2015%2F05%2F10%2F%E5%88%A9%E7%94%A8drozer%E8%BF%9B%E8%A1%8CAndroid%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%2F</url>
      <content type="text"><![CDATA[一、 drozer的安装与启动1、 安装第一步：从http://mwr.to/drozer下载Drozer (Windows Installer) 第二步：在Android设备中安装agent.apk1adb install agent.apk 2、 启动第一步：使用adb连接android设备12C:\Users\vv&gt;adb connect 20.20.20.55connected to 20.20.20.55:5555 第二步：使用adb进行端口转发，转发到Drozer使用的端口314151C:\Users\vv&gt;adb forward tcp:31415 tcp:31415 第三步：在Android设备上开启Drozer Agent选择embedded server-enable 第四步：切换到drozer安装的bin目录下，开启Drozer console1F:\drozer&gt;drozer console connect 输出信息：1234567891011121314151617181920212223242526java = C:\path\to\javaSelecting 8a04af64a8b990d8 (LENOVO Lenovo A850 4.2.2) .. ..:. ..o.. .r.. ..a.. . ....... . ..nd ro..idsnemesisand..pr .otectorandroidsneme. .,sisandprotectorandroids+. ..nemesisandprotectorandroidsn:. .emesisandprotectorandroidsnemes.. ..isandp,..,rotectorandro,..,idsnem. .isisandp..rotectorandroid..snemisis. ,andprotectorandroidsnemisisandprotec. .torandroidsnemesisandprotectorandroid. .snemisisandprotectorandroidsnemesisan: .dprotectorandroidsnemesisandprotector.drozer Console (v2.3.3)It seems that you are running an old version of drozer. drozer v2.3.4 wasreleased on 2015-02-20. We suggest that you update your copy to make sure thatyou have the latest features and fixes.To download the latest drozer visit: http://mwr.to/drozer/dz&gt; 最后如果出现如上信息就表示启动并连接成功了 二、 测试步骤1、 获取android手机上所有的包名12345678910dz&gt; run app.package.listMFT.test (MFT_Test)android (Android 绯荤粺)cn.wps.moffice (WPS Office)com.amap.android.location (缃戠粶浣嶇疆)com.android.backupconfirm (com.android.backupconfirm)com.android.browser (娴忚鍣?com.android.calculator2 (璁＄畻鍣?com.android.certinstaller (Certificate Installer)com.android.defcontainer (搴旂敤鍖呰闂潈闄愬府鍔╃▼搴?） 2、 获取android手机上口袋助理的包名12dz&gt; run app.package.list -f sangforcom.sangfor.pocket (鍙ｈ鍔╃悊) 3、 获取应用的基本信息1234567dz&gt; run app.package.info -a com.sangfor.pocketPackage: com.sangfor.pocket Application Label: 鍙ｈ鍔╃悊 Process Name: com.sangfor.pocket Version: 1.3.1......... 4、 确定攻击面1234567dz&gt; run app.package.attacksurface com.sangfor.pocketAttack Surface: 10 activities exported 8 broadcast receivers exported 0 content providers exported 6 services exported is debuggable 5、 Activity（1）获取activity信息1run app.activity.info -a com.sangfor.pocket （2）启动activity1234567891011run app.activity.start --component com.sangfor.pocketdz&gt; help app.activity.startusage: run app.activity.start [-h] [--action ACTION] [--category CATEGORY][--component PACKAGE COMPONENT] [--data-uri DATA_URI][--extra TYPE KEY VALUE] [--flags FLAGS [FLAGS ...]][--mimetype MIMETYPE] 6、 Content Provider（1）获取Content Provider信息123dz&gt; run app.provider.info -a com.sangfor.pocketPackage: com.sangfor.pocket No matching providers. （2）Content Providers（数据泄露） 先获取所有可以访问的Uri： 1run scanner.provider.finduris -a com.sangfor.pocket 获取各个Uri的数据： 1run app.provider.query content://com.sangfor.pocket.DBContentProvider/Passwords/ --vertical 查询到数据说明存在漏洞 （3）Content Providers（SQL注入）12run app.provider.query content://com.sangfor.pocket.DBContentProvider/Passwords/ --projection "'"run app.provider.query content://com.sangfor.pocket.DBContentProvider/Passwords/ --selection "'" 报错则说明存在SQL注入。 列出所有表：1run app.provider.query content://com.sangfor.pocket.DBContentProvider/Passwords/ --projection "* FROM SQLITE_MASTER WHERE type='table';--" 获取某个表（如Key）中的数据：1run app.provider.query content://com.sangfor.pocket.DBContentProvider/Passwords/ --projection "* FROM Key;--" （4）同时检测SQL注入和目录遍历123run scanner.provider.injection -a com.sangfor.pocket run scanner.provider.traversal -a com.sangfor.pocket 7、 Service（1）获取service详情1run app.service.info -a com.mwr.example.sieve 8、 其它模块12345678#在设备上开启一个交互shell shell.start#上传/下载文件到设备tools.file.upload / tools.file.download#安装可用的二进制文件tools.setup.busybox / tools.setup.minimalsu]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[本地化乌云网操作记录]]></title>
      <url>%2F2015%2F04%2F27%2F%E6%9C%AC%E5%9C%B0%E5%8C%96%E4%B9%8C%E4%BA%91%E7%BD%91%E6%93%8D%E4%BD%9C%E8%AE%B0%E5%BD%95%2F</url>
      <content type="text"><![CDATA[基于第三方项目：https://github.com/hanc00l/wooyun_public 一、 准备工作1、 python环境： 多版本共存pyenv 虚拟环境virtualenv 2、 安装命令：123pyenv install 2.7.10pyenv global 2.7.10pyenv virtualenv 2.7.10 venv2710 二、 具体操作步骤1、 进入虚拟环境1pyenv activate venv2710 2、 安装Flask注：（一个基于python的web开发微框架）1234#文档地址http://docs.jinkan.org/docs/flask/pip install Flask 3、 安装 Scrapy注：（一个基于python的爬虫框架）1234#文档地址http://scrapy-chs.readthedocs.io/zh_CN/0.24/intro/install.htmlpip install Scrapy 备注：需要Twisted&gt;=10.0.012345#下载wget https://pypi.python.org/packages/source/T/Twisted/Twisted-15.2.1.tar.bz2 #解压安装：python setup.py install 4、 安装pymongo1pip install pymongo 5、 启动web进入项目的flask目录下：python app.py 6、 开始爬虫12345#进入项目下的wooyun目录：scrapy crawl wooyun -a page_max=0 -a update=true#进入项目下的wooyun_drops目录：scrapy crawl wooyun -a page_max=0 -a update=true 备注：提示缺少PIL—http://www.pythonware.com/products/pil/解决：12345#下载wget http://effbot.org/downloads/Imaging-1.1.7.tar.gz#解压安装：python setup.py install 7、 mongodb+elasticsearchPS： mongodb使用elasticsearch必须要是集群下 编辑/home/ts/db/mongodb/mongodb.conf ，增加： 12replSet=rs0 #这里是指定replSet的名字oplogSize=100 #这里是指定oplog表数据大小（太大了不支持） 重启动mongodb 1service mongodb restart 进入mongodb shell，初始化replicSet 1rs.initiate( &#123;"_id" : "rs0", "version" : 1, "members" : [ &#123; "_id" : 0, "host" : "127.0.0.1:27017" &#125; ]&#125;) 备注：rs.initiate初始化字段详情见：https://docs.mongodb.com/manual/reference/replica-configuration/#replsetgetconfig-output 三、 还可能遇到的问题1、 virtualenv的环境无法import sqlite3报错信息如下：123456789101112#pythonPython 2.7.9 (default, Feb 10 2015, 01:40:34)[GCC 4.4.7 20120313 (Red Hat 4.4.7-11)] on linux2Type "help", "copyright", "credits" or "license" for more information.&gt;&gt;&gt; import sqlite3Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "/root/.pyenv/versions/2.7.9/lib/python2.7/sqlite3/__init__.py", line 24, in &lt;module&gt; from dbapi2 import * File "/root/.pyenv/versions/2.7.9/lib/python2.7/sqlite3/dbapi2.py", line 28, in &lt;module&gt; from _sqlite3 import *ImportError: No module named _sqlite3 谷歌了一下，原因是安装了多套python环境，virtualenv使用的那套python没有_sqlite3.so这个文件。没用virtualenv的时候，使用的是另外一套python的_sqlite3.so，所以解决方法是先安装sqlite-devel，然后重新编译virtualenv使用的那套python，操作步骤如下，因为我使用的pyenv，所以是连带virtualenv一起安装的。12345#先退出virtualenv的python环境，安装sqlite-develyum -y install sqlite-devel #重新安装pyenvcurl -L https://raw.githubusercontent.com/yyuu/pyenv-installer/master/bin/pyenv-installer | bash 删掉原有的python环境、重新安装python环境]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[移动互联网测试的所思所想]]></title>
      <url>%2F2015%2F04%2F06%2F%E7%A7%BB%E5%8A%A8%E4%BA%92%E8%81%94%E7%BD%91%E6%B5%8B%E8%AF%95%E7%9A%84%E6%89%80%E6%80%9D%E6%89%80%E6%83%B3%2F</url>
      <content type="text"><![CDATA[一、 操作问题 在不应该返回的时候返回了； 不耐心而且多次敲按键； 输入错误的数据； 不理解该怎么做； 可能没有按要求进行设置； 可能会自以为是地认为自己知道该怎做什么（比如通常不阅读说明） 二、 设计问题 如果处于一直被使用或者负荷情况下，状况会怎么样？会反应迟钝吗？会崩溃吗？会更新吗？有反馈吗？ 崩溃报告会反馈到App吗？ 用户可能有哪些创造性的、逻辑性的或是消极的导航方式？用户相信你的品牌吗？ 用户的数据安全如何？ 有可能被中断或是被破解吗？ 运行到极限时会发生什么状况？ 会要求打开相关服务吗(如GPS、Wi-Fi)？如果用户打开会怎样？没打开又会怎样？ 将用户重新引向哪儿？去网页？还是从网页到App？这会导致问题出现吗？ 沟通过程和市场反馈是否符合该App的功能、设计和内容？ 登录流程是怎样的？能在App上直接登录还是要去网页端？ 登录是否整合了其他服务，比如用Facebook和Twitter帐号登录？ 三、 数据问题 移动设备数据已满； 测试人员移除了所有的数据； 测试人员删除了App，那数据怎么办？ 测试人员删除并重装了App，数据怎么办？ 过多或者过少的内容导致设计和布局的改变； 在不同的时间段和时区使用； 数据不同步； 同步被中断； 数据更新影响其他的服务（比如网页和云端服务）； 快速处理数据或是处理大量的数据； 使用无效的数据； 四、 UI问题 出错提醒的UI设计可以接受吗？ 错误信息内容可以理解吗？ 错误信息是否保持一致？ 这些错误信息有帮助吗？ 错误信息内容是否合适？ 这些错误是否符合惯例和标准？ 这些错误信息本身是否安全？ 运行记录和崩溃是否能被用户和开发者获得？ 是否所有的错误都被测试过？ 用户处理完错误信息后，将处于什么状态 是否在用户应该接受错误信息时，却没有错误信息弹出？ 五、 平台相关 是否遵照了这个特定平台的设计规范？ 与竞争对手以及行业内的设计相比如何？ 是否适应外围设备？ 触摸屏支持手势吗，如：轻拍、双击、长按、拖动、摇动、夹捏、轻拂、滑动？ 这个App可以被理解吗？ 当转动设备的方向时，有什么变化？ 可以使用地图和GPS吗？ 有用户指南吗？ 电子邮件的工作流程友好吗？ 通过网络分享时，它运行得流畅吗？是否整合了其他社交应用或网站？ 当用户正在进行多任务工作，并在不同App间切换的时候，它还运行正常吗？ 当用户更新它时，它是否会显示时间进度？ 默认设置如何?有经过调整吗？ 使用音效会有不同吗？ 六、 连接问题 走动环境下？ Wi-Fi连接下？ 没有Wi-Fi的情况下？ 3G模式下？ 间歇性地连接？ 设置为飞行模式？ 一个电话打进来时？ 接收到一条信息时？ 接收到一个提醒通知时？ 在电量很低甚至自动关机时？ 被强制更新时？ 收到一条语音留言时？ 七、 外界环境 我可以下载这个App吗？ 我可以下载并安装更新吗？ 更新之后还能使用吗？ 当很多App处于等待更新状态时，我能更新它吗？ 系统更新后，它会发生什么？ 系统未更新，它又会发生什么？ 它会通过iTunes自动同步下载到其他设备吗？ 它自动执行任务或测试有意义吗？ 它会连接到网络服务吗？这会带来什么不同？ 八、 其他 测试用户可输入的极限值； 用重复的数据进行测试； 在全新无数据的手机里测试； 在老手机上测试； 预先安装不同类型的数据； 考虑聚集大家的资源来进行测试； 让一些测试自动化； 用一些超出预期的数据去测试，看它是怎么处理的； 分析信息和数据是怎么影响用户体验的； 不管用户看到的是否正确，都要一直问问题。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[redmine数据定期备份机制]]></title>
      <url>%2F2015%2F03%2F20%2Fredmine%E6%95%B0%E6%8D%AE%E5%AE%9A%E6%9C%9F%E5%A4%87%E4%BB%BD%E6%9C%BA%E5%88%B6%2F</url>
      <content type="text"><![CDATA[一、 简介目前项目管理用的是redmine，上面有bug记录和功能记录，为了防止因为某些原因导致数据不可恢复性的丢失，故需要对redmine进行定期的备份。 虽然redmine使用的是mysql数据库，可以使用mysql自带的工具进行数据的备份恢复，但是因为redmine上的数据包括各种附件（图片和文件等），所以如果是只是备份mysql数据库的话，那么这些附件必然会丢失。所以决定采用整个项目备份的方案：将整个项目每天定时压缩，按日期来命名，然后上传到一个专门的备份服务器上保存。同时该服务器上每天定时清理7天之前的备份数据，避免备份数据无限制增长。 二、 备份机制备份脚本存放在redmine系统上，每天凌晨2点左右备份，并上传到备份服务器，全量备份：备份的是整个redmine项目，以时间命名文件，可以看到最新备份的是哪一天的文件。具体脚本如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#!/bin/bash#program:# usage:sh backup_redmine.sh# function:auto backup redmine to IP at 2 o'clock everyday#author：tunsuy#date：2014/8/27#last change date:2014/8/27PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/binexport PATHfunction get_shell_dir() &#123; SOURCE="$0" while [ -h "$SOURCE" ]; do DIR="$( cd -P "$( dirname "$SOURCE" )" &amp;&amp; pwd )" SOURCE="$(readlink "$SOURCE")" [[ $SOURCE != /* ]] &amp;&amp; SOURCE="$DIR/$SOURCE" done DIR="$( cd -P "$( dirname "$SOURCE" )" &amp;&amp; pwd )" echo $DIR&#125;dir=$(get_shell_dir)DATE=$(date +"%Y-%m-%d")tar -czf $&#123;dir&#125;/redmine_backup_$&#123;DATE&#125;.tar.gz /opt/redmine-2.6.0-3password="moatest"/bin/rpm -qa | grep -q expectif [ $? -ne 0 ]; then echo "please install expect" exit 1fiexpect -c " spawn scp -P 22 $&#123;dir&#125;/redmine_backup_$&#123;DATE&#125;.tar.gz root@200.200.169.161:/home/tunsuy/redmine_backup; expect &#123; \"yes/no\" &#123;send \"yes\r\"; exp_continue;&#125; \"password\" &#123;set timeout 300; send \"$password\r\";&#125; &#125;expect eof"rm -rf $&#123;dir&#125;/redmine_backup_$&#123;DATE&#125;.tar.gz 采用的是linux下cron定时机制，定时配置脚本如下：159 1 * * * /home/ts/backup_redmine.sh &gt;/home/ts/backup-redmine.log 2&gt;&amp;1 脚本执行log：/home/ts/backup-redmine.log 三、 删除备份文件机制为了防止备份服务器上redmine的备份文件无限制增长，故每天凌晨3点左右，执行删除备份文件脚本，删除7天前的备份删除备份脚本如下：123#!/bin/bashfind /home/tunsuy/redmine_backup/ -mtime +7 -name "redmine_backup_*.tar.gz" -exec rm -rf &#123;&#125; \; 同样的，采用的是linux下cron定时机制，定时配置脚本如下：100 3 * * * /home/tunsuy/del-7days-ago-redmine.sh &gt;/home/tunsuy/del-redmine.log 2&gt;&amp;1 脚本执行log：/home/tunsuy/del-redmine.log 四、 cron简介1、cron定时执行日志：/var/log/cron* 2、cron定时配置文件：/var/spool/cron/root注：通过cron -e命令会自动打开一个文件，然后将定时任务写进去，保存，将在/var/spool/cron/下生成一个当前用户名命名的文件 3、cron -l可以查看所有的定时任务]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[gitbook使用相关]]></title>
      <url>%2F2015%2F03%2F15%2Fgitbook%E4%BD%BF%E7%94%A8%E7%9B%B8%E5%85%B3%2F</url>
      <content type="text"><![CDATA[gitbook的安装就不多说了，网上很多，很容易 一、 相关问题下面说几个自定义相关的问题 1、 自定义页面样式 默认样式是在：./_book/gitbook/style.cssps：增加样式只会覆盖自己定义的样式，其他的不变 在gitbook项目根目录下，创建styles目录注：一定要在该目录下创建，在其他目录下创建在gitbook build的时候会被清除掉 在styles目录下创建website.css——该文件是对gitbook页面样式的自定义 编辑book.json文件：加入 123"styles": &#123; "website": "styles/website.css" &#125;, 编译gitbook build 运行gitbook serve——就可以看到效果了 2、 自定义插件 增加插件”plugins”: [&quot;toggle-chapters&quot;,&quot;splitter&quot;], 去掉插件”plugins”: [&quot;-toggle-chapters&quot;,&quot;splitter&quot;],—在前面加上’—‘即可]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[centos下安装mongodb记录]]></title>
      <url>%2F2015%2F03%2F10%2Fcentos%E4%B8%8B%E5%AE%89%E8%A3%85mongodb%E8%AE%B0%E5%BD%95%2F</url>
      <content type="text"><![CDATA[一、 安装步骤1、 卸载已有mongodb数据库12/etc/init.d/mongod stopyum erase $(rpm -qa | grep mongodb-org) 删除mongodb相关目录文件等，例如：12rm -r /var/log/mongodb/rm -r /var/lib/mongo 2、 下载最新mongodb1wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel62-3.2.9.tgz 3、 移动下载文件并解压12mv ./mongodb-linux-x86_64-rhel62-3.2.9.tgz /usr/local/src/tar -xvf mongodb-linux-x86_64-rhel62-3.2.9.tgz 4、 移动解压文件1mv ./mongodb-linux-x86_64-rhel62-3.2.9 /usr/local/mongodb 5、 创建mongodb相关目录12mkdir -p /home/ts/db/mongodb/datamkdir -p /home/ts/db/mongodb/log 6、 创建并编辑mongodb配置文件1vim /home/ts/db/mongodb/mongodb.conf 二、 配置mongodb环境变量编辑：vim /etc/profile加入如下语句：123# mongodb setexport MONGODB=/usr/local/mongodbPATH=$PATH:$MONGODB/bin 立即生效：1source /etc/profile 三、 配置开机启动编辑：vim /etc/rc.d/init.d/mongod注：必须在该文件开头写上：12# chkconfig: 2345 10 90# description: mongod .... 设置：12chmod +x /etc/rc.d/init.d/mongodchkconfig mongod on PS：/etc/init.d/ 是 /etc/rc.d/init.d/ 的软链接]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux下部署redmine]]></title>
      <url>%2F2015%2F03%2F04%2Flinux%E4%B8%8B%E9%83%A8%E7%BD%B2redmine%2F</url>
      <content type="text"><![CDATA[一、 安装步骤1、安装ruby环境——使用rvm比较方便 2、使用bitnami-redmine一键式安装包 3、远程访问不了——关闭防火墙即可 4、phpmyadmin无法远程访问——修改配置文件：/opt/redmine-2.6.0-3/apps/phpmyadmin/conf/httpd-app.conf修改如下：1234567891011121314151617181920212223242526&lt;Directory "/opt/redmine-2.6.0-3/apps/phpmyadmin/htdocs"&gt;# AuthType Basic# AuthName phpMyAdmin# AuthUserFile "/opt/redmine-2.6.0-3/apache2/users"# Require valid-userAllowOverride None &lt;IfModule php5_module&gt; php_value upload_max_filesize 80Mphp_value post_max_size 80M &lt;/IfModule&gt;&lt;IfVersion &lt; 2.3 &gt;Order allow,denyAllow from allSatisfy all&lt;/IfVersion&gt;&lt;IfVersion &gt;= 2.3&gt;Require all granted# Require local&lt;/IfVersion&gt;ErrorDocument 403 "For security reasons, this URL is only accessible using localhost (127.0.0.1) as the hostname."&lt;/Directory&gt; 重启服务即可：1/opt/redmine-2.6.0-3/ctlscript.sh restart 二、 操作redmine的数据库1、 redmine使用的数据库为mysql，如果在终端直接输入mysql命令，则是直接调用的你以前装的mysql，而不是redmine的mysql 2、redmine的mysql相关命令的路径为/opt/redmine-2.6.0-3/mysql/bin/ 3、redmine数据库默认有几个用户 一是你安装时填写的用户名和密码，使用这个用户登录mysql是看不到redmine的数据库的； 二是root用户，密码跟你安装时填写的密码一样，这个可以看到所有的数据库]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo+github博客部署问题记录]]></title>
      <url>%2F2015%2F02%2F20%2Fhexo-github%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%2F</url>
      <content type="text"><![CDATA[一、 博客简介现在越来越多的人开始有了自己的博客，记录一下自己的学习和生活，个人博客一般都是静态博客 搭建博客一般有几种方式：1、全部自己实现：包括服务器、自己做网站、购买域名等——费时费力费钱2、租用云服务器，采用静态博客生成工具：但是云服务器一般也是要付费的 那有没有免费的呢？答案是有的，那就是github 这里再说下静态博客工具+github的原理：以hexo+github为例（其他的静态博客生成工具类似） 静态博客一般就是帮我们将博客的外观和框架做成了模型，用户只需要专注于写文章（一般都支持使用md格式文档），然后使用博客工具命令生成静态网页；所以你将这些网页和资源放在任何web服务器上都可以运行 既然放在任何的web服务器上都可以运行，那么久有了github为我们提供的免费托管服务器，我们只需要将我们的静态网页和资源上传到github上即可 hexo+github的具体安装部署这里就不多说了，网上教程很多 二、 问题记录这里只记录几个常用需求问题 1、 推送hexo博客内容到github出现错误：1error: The requested URL returned error: 403 Forbidden 安装网上的方式都试了，都不行最后解决方法如下： 修改站点配置文件_config.yml1repository: git@github.com:tunsuy/tunsuy.github.io.git ps：之前是使用的https，不知道为什么不行 2、搜索引擎收录因为github不允许baidu爬虫，所以提交文章链接到baidu搜索引擎比较麻烦参考这篇文章：Hexo-优化：提交sitemap及解决百度爬虫抓取-GitHub-Pages-问题 3、字体配置编辑 ./themes/next/source/css/_variables/custom.styl推荐这样的字体族配置：Helvetica, Tahoma, Arial, STXihei, &quot;华文细黑&quot;, &quot;Microsoft YaHei&quot;, &quot;微软雅黑&quot;, sans-serif 4、文章目录配置编辑 ./themes/next/_config.yml12345678# Table Of Contents in the Sidebar# 控制是否显示目录toc: enable: true # Automatically add list number to toc. # 控制目录序号的显示 number: false ps: 要显示多级目录时，在用md编辑文章时，目录只能依次，而不能跨级eg：#-&gt;## ，而不能 #-&gt;### 5、分类hexo不支持一篇文章属于多个同级分类 6、文章内链接显示蓝色编辑：./themes/next/source/css/_common/components/post/post.styl加入如下css样式：123456789.post-body p a&#123; color: #0593d3; border-bottom: none; &amp;:hover &#123; color: #0477ab; text-decoration: underline; &#125;&#125; 7、Next主题宽度调节 打开 themes/next/source/css/_common/components/post/post-expand.styl 文件，找到1@media (max-width: 767px) 改为1@media (max-width: 1080px) 打开 themes/next/source/css/_variables/base.styl 文件，找到123$main-desktop = 960px$main-desktop-large = 1200px$content-desktop = 700px 修改 $main-desktop 和 $content-desktop 的数值：123$main-desktop = 1080px$main-desktop-large = 1200px$content-desktop = 810px Next.Mist 主题的文章宽度至此改完了。如果你用的是 Next.Pisces，还需要继续修改。 打开 themes/next/source/css/_schemes/Pisces/_layout.styl 文件，将第 4 行的 width改为1080px ，修改后如下：1234.header &#123; position: relative; margin: 0 auto; width: 1080px; 8、 在社交栏添加QQ邮箱先说下next添加社交链接的原理主要代码在 ./themes/next/layout/_macro/sidebar.swig 文件，如下：1234567891011121314&lt;div class="links-of-author motion-element"&gt; &#123;% if theme.social %&#125; &#123;% for name, link in theme.social %&#125; &lt;span class="links-of-author-item"&gt; &lt;a href="&#123;&#123; link &#125;&#125;" target="_blank" title="&#123;&#123; name &#125;&#125;"&gt; &#123;% if theme.social_icons.enable %&#125; &lt;i class="fa fa-fw fa-&#123;&#123; theme.social_icons[name] | default('globe') | lower &#125;&#125;"&gt;&lt;/i&gt; &#123;% endif %&#125; &#123;&#123; name &#125;&#125; &lt;/a&gt; &lt;/span&gt; &#123;% endfor %&#125; &#123;% endif %&#125;&lt;/div&gt; 下面看下怎么接入qq邮箱，主要使用qq邮箱的邮我组件1、在网页版qq邮箱的设置中找到邮我组件，按照提示生成html代码注：可以完全使用该代码生成的风格，也可以只用href=’xxx’这个链接即可 2、修改next配置文件在 ./themes/next/_config.yml 文件的 social: 处加上 Email: xxx。注：xxx就是刚才邮我组件代码中的href。在social_icons: 处加上 Email: envelope 这个是 FontAwesome icon 中的图标注：前面说过，也可以完全使用邮我组件自己的风格。 三、 好文推荐Hexo-SEO优化Hexo官方文档主题next官方文档Next优化Hexo+NexT主题配置备忘]]></content>
    </entry>

    
  
  
</search>
