1、服务器节点内存持续增长，如果排查
java：
top命令，通过内存排序，找到内存占用比较高的进程id
top -Hp 进程id——找到该进程下的内存占用比较高的线程id
jstat——
jstack -p pid —— 查看该线程堆栈
jmap——导出内存文件，通过mat进行可视化分析

python：

2、服务器节点cpu占用过高，如何排查

3、数据库压力过大，如何缓解
通过查看日志找到是哪个业务模块在频繁的操作数据库
可以从三个方面进行排查并进行解决
业务方面：
排查该业务模块代码，查看是否存在如下问题
* 能够批量操作（比如更新或者插入）的地方采用了循环一次一次的操作数据库——造成频繁的数据库io
* 采用select * 查询数据库，实际上业务可能就只需要几个字段
* 在涉及到函数的层层调用的情况下，每层函数都自己查询数据库，实际上能够通过参数传递，减少数据库io
通过解决以上的问题，如果还是没有解决问题，那么执行进行下一步的排查——数据库

数据库方面：
找到该业务模块涉及到的数据库表
* 根据业务的操作sql，查看数据表是否有对应的索引
* 通过explain命令查看sql的执行过程
* 根据以上两步的排查结果，更新或者新增索引——需要注意索引的性质
* 分库分表

根据业务情况，还可以加一个缓存层
缓存层：
* 软件选型：memcache or redis
* 数据一致性问题
* 应该怎么选择缓存数据——热点数据
* 缓存层的高可用等等

4、工作中有没有遇到比较有难点的问题，是怎么解决的
说一个比较典型的吧，就是任务调度的重构

说说三次握手的意义
之所以有三次握手，主要有以下几个原因：
1、避免历史连接，因为在网络不好的时候，有可能会导致重复发送第一次连接（也就是syn序号），这样前一次发送syn需要可能后到，有了第三次连接，client就可以根据server发送过来的第二次连接ack序号重置本次连接。
2、可以有效的保证双方都能收到对方的传输序号

为什么是四次挥手
因为在client主动发起fin的时候，server收到之后会先回复一个ack，然后接着继续处理没有处理完的请求，全部处理完了之后再发送fin关闭连接，也就是说server这边的ack和fin是分开发送的，所以会比三次握手连接的时候多一次交互。

四次挥手中，client最后的time_wait时间为什么是2mst？
是为了保证链路中的包都已经到达或者丢弃掉（及时在server发送重复fin的情况下）。因为如果过早的关闭的话，server重发的fin（因为网络原因，没有收到client的ack）被其他新的连接（同样的端口）给接收到，导致连接混乱。

对数据库的事务了解吗？简单说下呢
事务有ACID的特性，也就是原子性、一致性、隔离性、持久性，对同一个事务里面的操作，要么全部成功，要么全部失败，postgresql数据库还可以指定回滚点（savepoint），从而回滚到任意的点
说到事务，需要先提下数据库不一致性情况，有如下几种：
1、脏读：一个事务读取了另一个事务已经写入但还未提交的数据
2、不可重复读：一个事务再次读取相同数据时，发现该数据被另一个事务修改了（一般出现在update情况）
3、幻读：一个事务再次读取一组数据时，发现该组数据中增加或者减少了一部分数据（一般出现在insert或者delete情况）
4、序列号异常：提交一组事务时，出现跟按顺序执行该组事务执行结果不一致的情况
为了解决这些不一致情况，数据库提供了事务隔离机制：
1、读未提交：对应脏读
2、读提交：对应不可重复读
3、可重复读：postgresql的实现原理是在select的时候，创建一个当前时间戳的镜像，后续再这个事务中的操作都是针对这个时间戳之前的数据，所以可以重复读。因此很好的解决了不可重复读和幻读
4、序列化：postgresql的实现原理是在可重复读基础上加了一个监控，检测到值有变化就rollback
注：postgresql没有读未提交这个级别，等同于读已提交

既然说到了事务，那再说说数据库锁吧？
数据库锁分为行锁、表锁、页锁
表锁分为:
share:跟exclusive冲突
exclusive:跟share冲突
access share：在读取的时候，可以修改数据
row share：跟自身不冲突
row exclusive: 跟自身不冲突
因为row share 和 row exclusive不能冲突，这就需要更细粒度的锁，那就是行锁
举例来说：对于一个update操作，首先会获取row exclusive锁，然后会获取需要更新的行锁。
表锁分为默认加锁和显示加锁，默认加锁的意思就是指当我们执行某些sql语句的时候，会默认给对应的表加上对应的锁，根据sql而定
行锁分为for update/for share/for key share/for no key update，如果不想在并发的时候等待，可以使用加上not wait
判断共享的关键是不会自己冲突自己这个级别.
一个事务不会与自己冲突, 这些锁冲突作用于不同事务中.
任何只读取表而不修改的查询获得Access Share锁, 只与Access Exclusive锁模式冲突.
悲观锁模式, Select for update和Select for share命令会获得Row Share锁.
任何修改行数据的命令获得Row Exclusive锁(update, delete, insert), 记住是表级锁
修改表信息,并行创建索引的命令获得Share Update Exclusive锁(alter table validate, create index concurrently, vacuum).
创建索引的获得Share锁(create index),不带concurrently, 该模式与自己不会冲突
触发器, 修改表定义会获得Share Row Exclusive锁, alter table, create trigger
并行刷新视图会获得Exclusive锁, Refresh materialized view concurrently
刷新视图, 删除表等会获得Access Exclusive锁, 与所有操作都冲突
https://huija.github.io/2019/03/12/postgresql-mvcc/

说到了事务和锁，那么再说下mvcc吧？
mvcc全程叫多版本并发控制，是事务和锁的实现基础、为了能够达到并发的时候，新旧数据能够同时操作，因此数据库在更新数据的时候一般不会直接将旧数据删掉，两种方式：
1、更新数据时，将旧数据转移到其他地方，比如在回滚段中（undo log），需要读取旧数据的时候，就从回滚段中读取。oracle和mysql的innodb
2、更新数据时，直接插入新数据，新老数据共存。postgresql
下面说下postgresql的mvcc机制
postgresql会在每一行记录中增加两个只读字段xmin和xmax，xmin表示该记录当时的xid（事务id），xmax默认0，当更新或者删除记录的时候，将当前事务id赋值给xmax
postgresql会根据不同的隔离级别选择使用不同的快照（也就是xmin和xmax之间的记录集合），如下原则：
1、若xmin等于当前事务ID，则包含所有xmax=0（未被删除）的元组。
2、若与xmin相等的事务ID对应的事务已经被提交，则包含所有xmax=0或xmax为当前事务ID的元组。
https://wjqwsp.github.io/2016/09/05/PostgreSQL-MVCC%E6%9C%BA%E5%88%B6%E6%B5%85%E6%9E%90/

了解数据库索引吗？
索引本质上就是一种数据结构，为了高效的查询数据库数据而设计的一种数据结构，既然是数据查询，所以数据结构有顺序查找、二分查找、二叉查询树，但是这些数据结构的效率都很低，不能满足数据库查询的要求，因此一般作为索引的数据结构为B/B+树索引、哈希索引、全文索引等等。比如mysql常用的索引用的就是B+树

那你说说mysql的索引实现原理？
以innodb引擎的B+树索引为例，B+树是一个多阶树，非叶子节点存储的是主键key，叶子节点存储了主键key和数据（myisam则不一样，存储了key和对应数据的地址，因此myisam的叫非聚蔟索引，innodb的叫聚蔟索引），每个叶子节点均有一个指针指向其相邻的节点，便于高效的进行范围查找。
因为innodb的数据就是按照索引存储的，也就是说数据文件就是索引文件（myisam引擎不一样，索引文件是单独的），因此innodb要求一定要有主键，如果没有显示指定，则自动找一个可以作为唯一列作为主键，如果找不到，则自动生成一个隐藏字段作为主键。
InnoDB的辅助索引（除主键索引之外的其他索引）data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域（myisam则不一样，它的主键索引和辅助索引没有什么区别，都是存储的数据地址）
https://blog.codinglabs.org/articles/theory-of-mysql-index.html

你对设计模式了解吗，说说基本的solid原则吧
s: 单一职责原则，官方解释就是指一个类只能有一个修改它的理由，通俗的说就是一个类的职责需要单一，不能大而全
o：开放-关闭原则，官方解释就是指对外扩展开放，对内修改关闭。可以通过继承或者回调参数等方式对外扩展
l：里氏替换原则，子类可以任意的替换父类作用于任何的方法中，也就是说子类复写父类的方法时，需要完全保持一致，并且不能将其退化（可以考虑其是否是核心特性，提取到父类中）
d：依赖倒置原则，也就是说高层模块不能直接依赖底层模块，两者都需要依赖一个中间抽象层。这样可以做到，底层模块的修改不影响高层，
i：接口隔离原则，调用方不应该依赖它不需要的接口方法。


