# memcached常见问题

## 如何设计key
NoSQL和传统的RDBMS，并不是水火不容，两者在某些设计上，是可以相互参考的。对于memcached,Redis,这种kv存储，key的设计，可以参考MySQL中表与列的设计。

比如：user表下有age列,name列,身高列，对应的key，可以用user:133:age=23,user:133:name="test",user:133:height=168;  
可以将某一组key，按其共同前缀来分布，比如按照`user-133`来计算，而不是以`user-133-age，user-133-name，user-133-height`来计算，这样3个关于个人信息的key，都落在同一个节点，访问个人主页时，只需连接一个节点。

## memcache的永久数据真的会一直存在吗？
在实际使用中，常常有人发现，自己设置的永久数据，莫名其妙的丢失了。

其实，这要从两个方面来考虑：  
memcache的惰性删除机制和LRU算法淘汰机制  
通俗理解：  
数据在内存中失效后，并不会立马被删除，只有在下次get时候，系统才会将其删除。 因此，memcache可能被一些未被及时删除的数据占满空间。加之LRU淘汰机制，永久数据如果很少被访问的话，在内存空间被占满的情况下，再有新数据被缓存，则永久数据，就有可能被删除。

解决方案：  
永久数据和非永久数据分开放。

## memcached 有冗余机机制吗？
没有冗余，memcached 是你应用的缓存层。在设计上它没有任何的数据冗余的概念。如果一个节点丢失了它的数据，你可以重新从数据源获取所有数据。

## memcached 的失效策略是怎样的？
没有失效策略，在 memcached 节点失效时，集群根本不做任何有关失败转移的事情。应对的行为完全取决于用户。当节点失效时，下面有几种方案供你选择。

* 1. 忽略它！在失效节点恢复或被替换前，你有许多节点可以应对这个节点失效所带来的影响。

* 2. 从服务器列表中移除失效的节点。千万小心！默认情况下，客户端增加或删除服务器列表会让你的缓存失效！因为用来做哈希参照的服务器列表已经改变，大多数键可能会被哈希出不同的值而被定为到不同的服务器。可以在同一时间重启你所有的节点来恢复。

* 3. 可以用相同 IP 地址的节点替换失效的节点。这样可以防止哈希紊乱。

* 4. 使用一致的哈希算法来增加删除集群中的节点。参考其他的哈希算法。

## memcached 存在验证机制吗？
没有验证机制！ memcached 位于你应用的下层。完全没有验证机制的部分，原因是客户端和服务器端轻量化。这样建立新的连接会很快，也没有服务器端的配置。

如果不想要严格控制访问，你可以使用防火墙，或者可以通过 unix 的 domain socket 来为 memcached 监听。

## memcached有什么限制吗？
你可能会看到的最简单的限制是对键以及数据项的大小限制。键被限制在 250 字符之内。数据项不能超过 1M ，因为这是最大的块（ slab ）值。

## memcached 的内存分配是怎样工作的？为什么不用 malloc 或 free 呢？为什么要用 slabs ？
事实上，这是编译时的选项。默认情况下 memcached 用内部的 slab 作为分配器的。你真的很需要使用内建的 slab 分配器。一开始， memcached 的确用 malloc/free 分配所有东西。然而，这并不能同操作系统的内存管理器很好地工作。你的操作系统花在查找连续内存块用以 malloc() 的时间超出了 memcached 本身的操作运行时间。

slab 分配器就是用来解决这个问题的。在 memcached 内部以块为单位来分配和重用内存。因为内存被分为不同大小的 slab ，如果你的数据项没有完全符合服务器选择的 slab 的大小，这的确会导致浪费内存。 Steven Grimm 已经在这方面做了相当有效的改进。

如果你试图用 malloc/free 分配内存，你可以在构建中定义 'USE_SYSTEM_MALLIC' 。它可能没有经过很好测试，所以不用指望能得到开发者的支持。

## 储存list类型的数据
在memcached储存list类型的数据可以认为是存储序列化数组的单个数据项，也可以是在不操作整个数据集的前提下添加删除大集合内的数据项。或者两者皆有。
需要考虑的是memcached对数据项大小有1M的限制，所以在memcached存储整个集合可能不是一个好的方案。
Steven Grimm提出了一个较好的方案：
http://lists.danga.com/pipermail/memcached/2007-July/004578.html
Chris Hondl和Paul Stacey详细说明了另一种方案：
http://lists.danga.com/pipermail/memcached/2007-July/004581.html
两种方案的结合可能会产生具有相当规模的List。在某一范围内的IDs可以用不同的键储存，数据用各自的键储存。

## 用get_muti发起批量请求
如果你刚开始使用memcached，你可能会写出像下面一样的代码：
greet = get("Foo")
person = get("Bar")
place = get("Baz")
当你调整性能时，你可能会发现每次调用get()都会有以下过程：
get("Foo") - client - server - client
get("Bar") - client - server - client
get("Baz") - client - server - client
许多客户端都支持一次从单个memcached实例中获取多个键，有些客户端支持并行获取。如果有3个键在3台memcached上，请求会被同时发出，你只要等待最慢的那台返回数据后就可以得到所有数据。如果你有很多数据要取，这可以大大提高速度。
很多有关发出组合和并行请求的技术方案可以在邮件列表中找到http://lists.danga.com/pipermail/memcached/2007-July/004528.html 

 

 
