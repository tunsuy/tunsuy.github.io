synchronized的实现机制，以及锁升级过程
在java6之前，synchronized是通过操作系统的互斥锁（mutex_lock）原语实现，这样会导致每次都进行用户态和内核态的切换
在java6之后，synchronized通过偏向锁、轻量级锁、重量级锁控制，是一个逐渐升级的过程。在一个线程进入synchronized代码块时，会先检查该锁对象的对象头里面的标记
1、如果是无锁标记，则将该对象的对象头的锁标志置位01，并标识该对象所属的线程为自己，此时的对象锁为偏向锁。
2、如果是偏向锁，并且锁线程不是自己，则cas等待获取锁，此时的对象锁为轻量级锁
3、如果是轻量级锁，开始cas等待获取锁，如果在一定次数内获取失败，则升级为重量级锁，进入等待队列

volatile关键字是什么意思，底层是怎么实现的？
使用volatile修饰的变量具有线程可见性，即一个线程修改之后，其他线程均立即可见。
说到实现的话，得先说下操作系统的缓存机制，操作系统缓存分为cpu的寄存器、主存。每个线程在cpu中都有自己独立的寄存器，这个是线程隔离的，但是主存是共享的。一般情况下，一个线程操作变量分为三步：
1、从主存中读取变量的拷贝到自己的寄存器中
2、在寄存器中修改变量
3、将寄存器中的变量同步到主存中
但是寄存器到主存的数据同步是不是实时的，因此变量在多线程下存在竞争状态。在加了volatile修饰之后，jvm会将线程寄存器中的该变量实时同步到主存中，因此这样所有的线程都能实时的看到该变量的更新。

说说java中的线程池的几个参数的作用
1、corePoolSize: 核心线程队列大小，当该队列没有满时，对于新来的请求，会立即新开一个线程进行处理
2、maximumPoolSize：最大的线程队列大小，当核心线程队列和阻塞队列均满的时候，对新来的请求，会从阻塞队列中取出一个请求新开一个线程进行处理，然后将新请求放入阻塞队列中；如果线程达到最大的线程队列大小，则直接拒绝请求
3、keepAliveTime: 空间线程存活时间
4、BlockingQueue：当核心线程池满了的时候，对于新来的请求，会优先放入该队列
5、RejectedExecutionHandler：当执行中的线程达到最大线程队列大小的时候，对于新来的请求则执行该拒绝策略，默认提供了4种类型的策略

说一说访问权限
java中有四种 访问权限
1、private：同一个类可访问
2、default：同一个类和同一个包可访问
3、protected：同一个类、同一个包、不同包的子类可访问
4、public：任何地方可访问

说一说ReentrantLock
ReentrantLock是一个可重入锁，同时也是一个独占锁，它具有跟synchronized同样的锁机制和内存语义。它额外提供了定时锁、中断锁、锁投票更功能，分为公平锁和非公平锁
ReentrantLock通过一个FIFO的队列（同时也是一个双向链表）来管理等待该锁的线程，在公平锁的机制下，线程根据FIFO依次排队获取锁，而非公平锁的机制下，则是竞争获取锁
ReentrantLock中有一个实现了AQS（）的内部类，所有的锁逻辑都是通过这个内部类来实现的，ReentrantLock只是提供了对外友好的接口。
内部通过state属性来记录锁定的状态，同时实现可重入。当一个线程执行的时候，会首先获取该状态，如果为0.表示没有线程持有该锁，然后会通过CAS操作系统原语去更新state，同时将锁线程更新为本线程；如果state不为0，表示已经有线程持有该锁，然后检查该线程是否为本线程，如果是，则更新state计数；如果不是，有两种情况，如果只是尝试获取锁，那么久直接退出，如果是直接锁定，则会将生成本线程的一个节点加入队列中，等待获取锁。

既然说了ReentrantLock，那再说说ReentrantReadWriteLock呢，以及他们的区别
ReentrantReadWriteLock使用两把锁来解决问题，一个读锁，一个写锁
线程进入读锁的前提条件：
1、没有其他线程的写锁，
2、没有写请求或者有写请求，但调用线程和持有锁的线程是同一个
线程进入写锁的前提条件：
1、没有其他线程的读锁
2、没有其他线程的写锁
具有如下的特性：
1、重入方面其内部的WriteLock可以获取ReadLock，但是反过来ReadLock想要获得WriteLock则不行。 
2、WriteLock可以降级为ReadLock，顺序是：先获得WriteLock再获得ReadLock，然后释放WriteLock，这时候线程将保持Readlock的持有。反过来ReadLock想要升级为WriteLock则不可能 
3、ReadLock可以被多个线程持有并且在作用时排斥任何的WriteLock，而WriteLock则是完全的互斥。这一特性最为重要，因为对于高读取频率而相对较低写入的数据结构，使用此类锁同步机制则可以提高并发量。 
4、不管是ReadLock还是WriteLock都支持Interrupt，语义与ReentrantLock一致。 
5、WriteLock支持Condition并且与ReentrantLock语义一致，而ReadLock则不能使用Condition，否则抛出UnsupportedOperationException异常。 

知道java的线程间协作吗？
java的线程间协作有两种方式
1、notify/wait/notifyall: 因为java中的对象都有一个内置的锁对象，因为java对每个对象也都提供了这三个原语来操作这个锁对象。
2、使用Condition：condition提供了await/signal/signalall方法，分别对应object的那三个方法

说一说java中的同步阻塞队列（LinkedBlockingQueue）
LinkedBlockingQueue是一个单链表形式的多线程同步阻塞队列，可以指定队列大小
使用了两个互斥锁putLock和takeLock来控制队列的竞争访问，当从队列中加入元素的时候进行putLock锁定，当从队列中取出元素的时候进行takeLock锁定。
使用了两个条件变量notEmpty和notFull来进行队列空和满的通知或阻塞，当take一个空队列的时候，使用notEmpty.wait等待，当put一个满队列的时候，使用notFull.wait等待；同时当队列由空变为不空时，使用notEmpty.signal通知等待线程，当队列由满变为不满时，使用notFull.signal通知等待线程

hashmap的实现机制
hashmap不保证输入有序，也不保证序号不随时间变化，有两个重要的参数，容量和负载因子，当hashmap的使用容量达到总容量*负载因子时，会扩容2倍
采用链式地址法进行重hash，也就是说当节点冲突的时候，会在该节点上形成链表，当链表节点数达到一定数量的时候（8）就转换为红黑树，当节点数减少到一定数量的时候就退化为链表

synchronized与reentrantlock区别
ReentrantLock是Lock的实现类，是一个互斥的同步器，在多线程高竞争条件下，ReentrantLock比synchronized有更加优异的性能表现。
Lock必须手动获取与释放锁，而synchronized不需要手动释放和开启锁
Lock只适用于代码块锁，而synchronized可用于修饰方法、代码块等
ReentrantLock的优势体现在：
具备尝试非阻塞地获取锁的特性：当前线程尝试获取锁，如果这一时刻锁没有被其他线程获取到，则成功获取并持有锁
能被中断地获取锁的特性：与synchronized不同，获取到锁的线程能够响应中断，当获取到锁的线程被中断时，中断异常将会被抛出，同时锁会被释放
超时获取锁的特性：在指定的时间范围内获取锁；如果截止时间到了仍然无法获取锁，则返回

对象在内存中的状态
可达状态：当一个对象被创建后，若有一个以上的引用变量引用它，则这个对象在程序中处于可达状态。
可恢复状态：如果程序中某个对象不再有任何引用变量引用它，它就进入了可恢复状态。
不可达状态：当对象与所有引用变量的关联都被切断，且系统已经调用所有对象的finalize()方法后依然没有使对象变成可达状态，那么这个对象将永久的失去引用，最后变成不可达状态。

垃圾回收机制具有的特征
垃圾回收机制只负责回收堆内存的对象，不会回收任何物理资源（例如数据库连接、网络IO等资源）
程序无法精确控制垃圾回收的运行，垃圾回收会在合适的时候进行。当对象永久地失去引用后，系统就会在合适的时候回收它所占的内存
在垃圾回收机制回收任何对象之前，总会先调用它的finalize()方法，该方法可能使该对象重新复活（让一个引用变量重新引用该对象），从而导致垃圾回收机制取消回收。

强制触发垃圾回收方法
调用System类的gc()静态方法：System.gc();
调用Runtime对象的gc()实例方法：Runtime.getRuntime().gc();

Java的反射机制允许我们动态的调用某个对象的方法/构造函数、获取某个对象的属性等，而无需在编码时确定调用的对象。这种机制在我们常用的框架中也非常常见。
反射的原理之一其实就是动态的生成类似于上述的字节码，加载到jvm中运行。

java中反射的是怎么实现的？
首先这得从两个方面说。一个是jvm的层面，一个是java应用层的层面。
应用层层面：用传统的OOP思想来说，任何一个你写好的且编译过的生成的Class文件，在被类加载器加载后，都会对应有一个java.lang.Class<T> 这个类的实例。
所以说，每个类的自有的方法属性(类结构)自然被包含在了这个对应的实例上，因此就可以获取到。


java序列化号的作用 Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体（类）的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。 
1）在某些场合，希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的serialVersionUID；在某些场合，不希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有不同的serialVersionUID。 
2）当你序列化了一个类实例后，希望更改一个字段或添加一个字段，不设置serialVersionUID，所做的任何更改都将导致无法反序化旧有实例，并在反序列化时抛出一个异常。如果你添加了serialVersionUID，在反序列旧有实例时，新添加或更改的字段值将设为初始化值（对象为null，基本类型为相应的初始默认值），字段被删除将不设置。 

synchronized有哪几种锁对象
1. 在对象上使用synchronized，锁对象就是该对象锁
2. 在普通成员方法上使用synchronized，锁对象就是类实例对象锁
3. 在静态成员方法上使用synchronized，锁对象就是类对象锁
