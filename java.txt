synchronized的实现机制，以及锁升级过程
在java6之前，synchronized是通过操作系统的互斥锁（mutex_lock）原语实现，这样会导致每次都进行用户态和内核态的切换
在java6之后，synchronized通过偏向锁、轻量级锁、重量级锁控制，是一个逐渐升级的过程。在一个线程进入synchronized代码块时，会先检查该锁对象的对象头里面的标记
1、如果是无锁标记，则将该对象的对象头的锁标志置位01，并标识该对象所属的线程为自己，此时的对象锁为偏向锁。
2、如果是偏向锁，并且锁线程不是自己，则cas等待获取锁，此时的对象锁为轻量级锁
3、如果是轻量级锁，开始cas等待获取锁，如果在一定次数内获取失败，则升级为重量级锁，进入等待队列

volatile关键字是什么意思，底层是怎么实现的？
使用volatile修饰的变量具有线程可见性，即一个线程修改之后，其他线程均立即可见。
说到实现的话，得先说下操作系统的缓存机制，操作系统缓存分为cpu的寄存器、主存。每个线程在cpu中都有自己独立的寄存器，这个是线程隔离的，但是主存是共享的。一般情况下，一个线程操作变量分为三步：
1、从主存中读取变量的拷贝到自己的寄存器中
2、在寄存器中修改变量
3、将寄存器中的变量同步到主存中
但是寄存器到主存的数据同步是不是实时的，因此变量在多线程下存在竞争状态。在加了volatile修饰之后，jvm会将线程寄存器中的该变量实时同步到主存中，因此这样所有的线程都能实时的看到该变量的更新。

说说java中的线程池的几个参数的作用
1、corePoolSize: 核心线程队列大小，当该队列没有满时，对于新来的请求，会立即新开一个线程进行处理
2、maximumPoolSize：最大的线程队列大小，当核心线程队列和阻塞队列均满的时候，对新来的请求，会从阻塞队列中取出一个请求新开一个线程进行处理，然后将新请求放入阻塞队列中；如果线程达到最大的线程队列大小，则直接拒绝请求
3、keepAliveTime: 空间线程存活时间
4、BlockingQueue：当核心线程池满了的时候，对于新来的请求，会优先放入该队列
5、RejectedExecutionHandler：当执行中的线程达到最大线程队列大小的时候，对于新来的请求则执行该拒绝策略，默认提供了4种类型的策略

